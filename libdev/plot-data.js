/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("PlotData", [], factory);
	else if(typeof exports === 'object')
		exports["PlotData"] = factory();
	else
		root["PlotData"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://PlotData/./node_modules/events/events.js?");

/***/ }),

/***/ "./src/axes.ts":
/*!*********************!*\
  !*** ./src/axes.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Axis\": () => (/* binding */ Axis),\n/* harmony export */   \"ParallelAxis\": () => (/* binding */ ParallelAxis),\n/* harmony export */   \"TitleSettings\": () => (/* binding */ TitleSettings)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions */ \"./src/functions.ts\");\n/* harmony import */ var _baseShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./baseShape */ \"./src/baseShape.ts\");\n/* harmony import */ var _primitives__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./primitives */ \"./src/primitives.ts\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shapes */ \"./src/shapes.ts\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\nclass TitleSettings {\n    constructor(origin = null, align = null, baseline = null, orientation = null) {\n        this.origin = origin;\n        this.align = align;\n        this.baseline = baseline;\n        this.orientation = orientation;\n    }\n}\nclass Axis extends _baseShape__WEBPACK_IMPORTED_MODULE_2__.Shape {\n    constructor(vector = null, boundingBox, origin, end, name = '', initScale, _nTicks = 10) {\n        super();\n        this.boundingBox = boundingBox;\n        this.origin = origin;\n        this.end = end;\n        this.name = name;\n        this.initScale = initScale;\n        this._nTicks = _nTicks;\n        this.ticksFontsize = 12;\n        this.isDiscrete = true;\n        this.isInteger = false;\n        this.logScale = false;\n        this.isDate = false;\n        this.lineWidth = 1;\n        this.strokeStyle = 'hsl(0, 0%, 0%)';\n        this.hoverStyle = 'hsl(0, 100%, 48%)';\n        this.clickedStyle = 'hsl(126, 67%, 72%)';\n        this.rubberColor = 'hsl(200, 95%, 50%)';\n        this.rubberAlpha = 0.5;\n        this.mouseStyleON = false;\n        this.isHovered = false;\n        this.isClicked = false;\n        this.isInverted = false;\n        this.centeredTitle = false;\n        this.titleSettings = new TitleSettings();\n        this.font = 'sans-serif';\n        this.emitter = new events__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();\n        this._marginRatio = 0.05;\n        // OLD\n        this.is_drawing_rubberband = false;\n        this.discretePropertiesFromVector(vector);\n        const [minValue, maxValue] = this.computeMinMax(vector);\n        [this._previousMin, this._previousMax] = [this.initMinValue, this.initMaxValue] = [this.minValue, this.maxValue] = this.marginedBounds(minValue, maxValue);\n        this.ticks = this.computeTicks();\n        if (!this.isDiscrete)\n            this.labels = this.numericLabels();\n        this.computeEnds();\n        this.adjustBoundingBox();\n        this.drawnPath = this.buildArrowPath();\n        this.buildPath();\n        this.buildRubberBand();\n        this.updateOffsetTicks();\n        this.offsetTitle = 0;\n        this.title = new _shapes__WEBPACK_IMPORTED_MODULE_4__.Text(this.titleText, new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(0, 0), {});\n    }\n    ;\n    get drawLength() {\n        return this.isVertical ? Math.abs(this.origin.y - this.end.y) : Math.abs(this.origin.x - this.end.x);\n    }\n    get drawingColor() {\n        let color = this.strokeStyle;\n        if (this.mouseStyleON) {\n            color = this.isHovered ? this.hoverStyle : this.isClicked ? this.clickedStyle : this.strokeStyle;\n        }\n        ;\n        return color;\n    }\n    get interval() { return Math.abs(this.maxValue - this.minValue); }\n    ;\n    get drawScale() { return this.drawLength / this.interval; }\n    get center() { return (this.maxValue + this.minValue) / 2; }\n    get isVertical() { return this.origin.x == this.end.x; }\n    ;\n    set marginRatio(value) { this._marginRatio = value; }\n    ;\n    get marginRatio() { return this._marginRatio; }\n    ;\n    get tickMarker() { return \"halfLine\"; }\n    get tickOrientation() {\n        return this.isVertical\n            ? this.initScale.x > 0 ? 'right' : 'left'\n            : this.initScale.y > 0 ? 'up' : 'down';\n    }\n    get minValue() { return this._minValue; }\n    set minValue(value) { this._minValue = value; this.emitter.emit(\"axisStateChange\", this); }\n    get maxValue() { return this._maxValue; }\n    set maxValue(value) { this._maxValue = value; }\n    set nTicks(value) { this._nTicks = value; }\n    ;\n    get nTicks() {\n        if (this.isDiscrete)\n            return this.labels.length + 1;\n        return this._nTicks;\n    }\n    get ticks() { return this._ticks; }\n    set ticks(value) { this._ticks = value; }\n    get titleText() { return _shapes__WEBPACK_IMPORTED_MODULE_4__.Text.capitalize(this.name); }\n    get transformMatrix() { return this.getValueToDrawMatrix(); }\n    get areAllLabelsDisplayed() { return this.isDiscrete && this.ticks.length > (0,_functions__WEBPACK_IMPORTED_MODULE_1__.uniqueValues)(this.labels).length + 2; }\n    updateOffsetTicks() { this.offsetTicks = Math.abs(this.boundingBox.size[this.isVertical ? \"x\" : \"y\"]) * 0.25; }\n    horizontalPickIdx() { return Math.sign(1 - Math.sign(this.initScale.y)); }\n    verticalPickIdx() { return Math.sign(1 - Math.sign(this.initScale.x)); }\n    computeEnds() { }\n    toggleView() { this.visible = !this.visible; }\n    getLogBoundaries(vector) {\n        const positiveVector = vector.filter(value => value > 0);\n        const min = Math.min(...positiveVector);\n        const max = Math.max(...positiveVector);\n        if (max <= 0) {\n            this.logScale = false;\n            return [this.initMinValue, this.initMaxValue];\n        }\n        if (this.logScale) {\n            return [\n                this.initMinValue > 0 ? Math.log10(this.initMinValue) : Math.log10(min),\n                this.initMaxValue > 0 ? Math.log10(this.initMaxValue) : Math.log10(max)\n            ];\n        }\n        else\n            return [10 ** this.initMinValue, 10 ** this.initMaxValue];\n    }\n    switchLogScale(vector) {\n        if (!this.isDiscrete) {\n            this.logScale = !this.logScale;\n            [this.initMinValue, this.initMaxValue] = this.getLogBoundaries(vector);\n            this.updateTicks();\n        }\n    }\n    discretePropertiesFromVector(vector) {\n        if (vector) {\n            if (vector.length != 0) {\n                this.isDate = vector[0] instanceof Date;\n                this.isDiscrete = !this.isDate && typeof vector[0] == 'string';\n            }\n            if (this.isDiscrete)\n                this.labels = vector.length != 0 ? (0,_functions__WEBPACK_IMPORTED_MODULE_1__.uniqueValues)(vector) : [\"0\", \"1\"];\n            else\n                this.isInteger = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.isIntegerArray)(vector) && !this.isDate;\n        }\n        else {\n            this.isDiscrete = true;\n            this.labels = [\"0\", \"1\"];\n        }\n    }\n    otherAxisScaling(otherAxis) {\n        const center = this.center;\n        this.maxValue = this.minValue + otherAxis.interval * this.drawLength / otherAxis.drawLength;\n        const translation = center - this.center;\n        this.minValue += translation;\n        this.maxValue += translation;\n    }\n    transform(newOrigin, newEnd) {\n        this.origin = newOrigin.copy();\n        this.end = newEnd.copy();\n        this.rubberBand.isVertical = this.isVertical;\n        this.drawnPath = this.buildArrowPath();\n        this.buildPath();\n        this.emitter.emit(\"axisStateChange\", this);\n    }\n    resetScale() {\n        this.minValue = this.initMinValue;\n        this.maxValue = this.initMaxValue;\n        this._previousMin = this.minValue;\n        this._previousMax = this.maxValue;\n        this.updateTicks();\n    }\n    reset() {\n        this.rubberBand.reset();\n        this.resetScale();\n    }\n    update(axisStyle, viewPoint, scale, translation) {\n        axisStyle.forEach((value, key) => this[key] = value);\n        this.updateScale(viewPoint, scale, translation);\n    }\n    updateStyle(axisStyle) { axisStyle.forEach((value, key) => this[key] = value); }\n    buildRubberBand() {\n        this.rubberBand = new _shapes__WEBPACK_IMPORTED_MODULE_4__.RubberBand(this.name, 0, 0, this.isVertical);\n        this.defaultRubberBandStyle();\n    }\n    defaultRubberBandStyle() {\n        this.rubberBand.lineWidth = 0.1;\n        this.rubberBand.fillStyle = this.rubberColor;\n        this.rubberBand.strokeStyle = this.rubberColor;\n        this.rubberBand.alpha = this.rubberAlpha;\n    }\n    sendRubberBand(rubberBands) { this.rubberBand.selfSend(rubberBands); }\n    sendRubberBandRange(rubberBands) { this.rubberBand.selfSendRange(rubberBands); }\n    static nearestFive(value) {\n        const tenPower = Math.floor(Math.log10(Math.abs(value)));\n        const normedValue = Math.floor(value / Math.pow(10, tenPower - 2));\n        const fiveMultiple = Math.floor(normedValue / 50);\n        return (50 * fiveMultiple) * Math.pow(10, tenPower - 2);\n    }\n    adjustBoundingBox() {\n        if (this.isVertical) {\n            this.boundingBox.size.x += _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END / 2;\n            this.boundingBox.size.y += _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END;\n        }\n        else {\n            this.boundingBox.size.x += _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END;\n            this.boundingBox.size.y += _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END / 2;\n        }\n        this.boundingBox.buildPath();\n    }\n    absoluteToRelative(value) {\n        let numberedValue = this.stringToValue(value);\n        const projectedValue = this.isVertical\n            ? (numberedValue - this.transformMatrix.f) / this.transformMatrix.a\n            : (numberedValue - this.transformMatrix.e) / this.transformMatrix.a;\n        return this.logScale ? 10 ** projectedValue : projectedValue;\n    }\n    relativeToAbsolute(value) {\n        let numberedValue = this.stringToValue(value);\n        if (this.logScale)\n            numberedValue = Math.log10(numberedValue);\n        return this.isVertical\n            ? numberedValue * this.transformMatrix.d + this.transformMatrix.f\n            : numberedValue * this.transformMatrix.a + this.transformMatrix.e;\n    }\n    normedValue(value) { return value / this.interval; }\n    computeMinMax(vector) {\n        if (!(vector === null || vector === void 0 ? void 0 : vector.length))\n            return [0, 1];\n        if (this.isDiscrete)\n            return [0, this.labels.length - 1];\n        const min = Math.min(...vector);\n        const max = Math.max(...vector);\n        return min != max ? [min, max] : min != 0 ? [min * (min < 0 ? 1.3 : 0.7), max * (max < 0 ? 0.7 : 1.3)] : [-1, 1];\n    }\n    getCalibratedTextWidth(context) {\n        const calibratedTickText = new _shapes__WEBPACK_IMPORTED_MODULE_4__.Text(\"88.88e+88\", new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(0, 0), { fontsize: _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE, font: this.font });\n        context.font = calibratedTickText.fullFont;\n        const calibratedMeasure = context.measureText(calibratedTickText.text).width;\n        return [calibratedTickText, calibratedMeasure];\n    }\n    computeTextBoxes(context) {\n        context.save();\n        const [calibratedTickText, calibratedMeasure] = this.getCalibratedTextWidth(context);\n        this.maxTickWidth = Math.min(this.boundingBox.size.x - this.offsetTicks - 3, calibratedMeasure);\n        this.maxTickHeight = Math.min(this.boundingBox.size.y - this.offsetTicks - 3, calibratedTickText.fontsize);\n        if (this.centeredTitle)\n            this.centeredTitleTextBoxes(calibratedMeasure);\n        context.restore();\n    }\n    centeredTitleTextBoxes(calibratedMeasure) {\n        let freeSpace;\n        if (this.isVertical) {\n            freeSpace = this.boundingBox.size.x - _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE - 0.3 * this.maxTickWidth;\n            this.offsetTitle = Math.min(freeSpace, calibratedMeasure);\n            this.maxTickHeight -= this.offsetTitle;\n        }\n        else {\n            freeSpace = this.boundingBox.size.y - _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE - 0.3 * this.maxTickHeight;\n            this.offsetTitle = Math.min(freeSpace, _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE * 1.5 + this.offsetTicks);\n            this.maxTickWidth -= this.offsetTitle;\n        }\n    }\n    integerTickIncrement(rawIncrement, logExponent) {\n        return rawIncrement >= 1 ? Math.floor(rawIncrement / 10 ** logExponent) * 10 ** logExponent : 1;\n    }\n    floatTickIncrement(rawIncrement, logExponent) {\n        const tenPower = logExponent > 0 ? 1 : 15;\n        return Math.round(rawIncrement * 10 ** tenPower) / 10 ** tenPower;\n    }\n    getTickIncrement() {\n        const rawIncrement = this.isDiscrete ? 1 : Axis.nearestFive((this.maxValue - this.minValue) / this.nTicks);\n        const logExponent = Math.floor(Math.log10(rawIncrement));\n        if (this.isInteger && !this.logScale)\n            return this.integerTickIncrement(rawIncrement, logExponent);\n        return this.floatTickIncrement(rawIncrement, logExponent);\n    }\n    ticksTenPower(ticks) {\n        const tenPower = Math.max(...ticks.map(tick => { return (0,_functions__WEBPACK_IMPORTED_MODULE_1__.getTenPower)(tick); }));\n        return tenPower > 0 ? tenPower : 0;\n    }\n    incrementPrecision(increment, ticks) {\n        const tickTenPower = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.getTenPower)(ticks[ticks.length - 1] - ticks[0]);\n        const incrementTenPower = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.getTenPower)(increment);\n        const unitIncrement = increment / 10 ** incrementTenPower;\n        const splitUnitIncrement = unitIncrement.toString().split('.');\n        return tickTenPower - incrementTenPower + (splitUnitIncrement.length > 1 ? 2 : 1);\n    }\n    updateTickPrecision(increment, ticks) {\n        const splitNumber = increment.toString().split('.');\n        const tickTenPower = splitNumber.length > 1 ? this.ticksTenPower(ticks) : 0;\n        this.tickPrecision = tickTenPower + (splitNumber.length > 1 ? splitNumber[1].length + 1 : this.incrementPrecision(increment, ticks));\n        if (ticks.length > 1) {\n            for (let index = 0; index < ticks.length - 1; index++) {\n                const rightTick = ticks[index + 1];\n                const leftTick = ticks[index];\n                while (Number(rightTick.toPrecision(this.tickPrecision)) / Number(leftTick.toPrecision(this.tickPrecision)) == 1) {\n                    this.tickPrecision++;\n                }\n                ;\n            }\n        }\n        else if (this.isInteger && ticks.length > 0)\n            this.tickPrecision = ticks[0].toString().length;\n    }\n    ;\n    computeTicks() {\n        const increment = this.getTickIncrement();\n        const remainder = this.minValue % increment;\n        let ticks = [this.minValue - remainder];\n        while (ticks.slice(-1)[0] <= this.maxValue)\n            ticks.push(ticks.slice(-1)[0] + increment);\n        if (ticks.slice(0)[0] < this.minValue)\n            ticks.splice(0, 1);\n        if (ticks.slice(-1)[0] >= this.maxValue)\n            ticks.splice(-1, 1);\n        this.updateTickPrecision(increment, ticks);\n        return this.logScale ? ticks.map(tick => 10 ** tick) : ticks;\n    }\n    buildEndPoint(isVerticalBin, isHorizontalBin) {\n        if (this.isInverted) {\n            return new _primitives__WEBPACK_IMPORTED_MODULE_3__.Point(this.origin.x - _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END / 2 * isHorizontalBin, this.origin.y - _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END / 2 * isVerticalBin, _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END, 'triangle', ['left', 'down'][isVerticalBin]);\n        }\n        return new _primitives__WEBPACK_IMPORTED_MODULE_3__.Point(this.end.x + _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END / 2 * isHorizontalBin, this.end.y + _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END / 2 * isVerticalBin, _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END, 'triangle', ['right', 'up'][isVerticalBin]);\n    }\n    buildArrowPath() {\n        const isVerticalBin = Number(this.isVertical);\n        const isHorizontalBin = Number(!this.isVertical);\n        const path = new Path2D();\n        const endArrow = this.buildEndPoint(isVerticalBin, isHorizontalBin);\n        path.moveTo(this.origin.x - _constants__WEBPACK_IMPORTED_MODULE_0__.AXIS_TAIL_SIZE * isHorizontalBin, this.origin.y - _constants__WEBPACK_IMPORTED_MODULE_0__.AXIS_TAIL_SIZE * isVerticalBin);\n        path.lineTo(this.end.x, this.end.y);\n        path.addPath(endArrow.path);\n        return path;\n    }\n    buildPath() {\n        this.path = new Path2D();\n        const offset = new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(_constants__WEBPACK_IMPORTED_MODULE_0__.RUBBERBAND_SMALL_SIZE * Number(this.isVertical), _constants__WEBPACK_IMPORTED_MODULE_0__.RUBBERBAND_SMALL_SIZE * Number(!this.isVertical));\n        const origin = new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(this.origin.x, this.origin.y).subtract(offset.multiply(2));\n        const size = this.end.subtract(origin).add(offset);\n        this.path.rect(origin.x, origin.y, size.x, size.y);\n    }\n    buildDrawPath(context) {\n        this.drawnPath = this.buildArrowPath();\n        this.buildPath();\n        this.computeTextBoxes(context);\n    }\n    setDrawingProperties(context) {\n        context.strokeStyle = this.drawingColor;\n        context.setLineDash([]);\n        context.fillStyle = this.drawingColor;\n        context.lineWidth = this.lineWidth;\n    }\n    drawTicks(context, canvasMatrix) {\n        const pointHTMatrix = canvasMatrix.multiply(this.transformMatrix);\n        const [ticksPoints, ticksTexts] = this.drawTicksPoints(context, pointHTMatrix, this.drawingColor);\n        this.ticksPoints = ticksPoints;\n        this.drawTickTexts(ticksTexts, this.drawingColor, context);\n    }\n    drawTexts(context, canvasMatrix) {\n        context.resetTransform();\n        this.drawTicks(context, canvasMatrix);\n        this.drawTitle(context, canvasMatrix, this.drawingColor);\n    }\n    drawMembers(context) {\n        context.save();\n        const canvasMatrix = context.getTransform();\n        this.drawTexts(context, canvasMatrix);\n        this.drawRubberBand(context, canvasMatrix);\n        context.restore();\n    }\n    getTitleTextParams(color, align, baseline, orientation) {\n        return {\n            width: this.titleWidth,\n            fontsize: _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE,\n            font: this.font,\n            align: align,\n            color: color,\n            baseline: baseline,\n            style: 'bold',\n            orientation: orientation,\n            backgroundColor: \"hsla(0, 0%, 100%, 0.5)\",\n            scale: new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(1, 1)\n        };\n    }\n    formatTitle(text, context) { text.format(context); }\n    updateTitle(context, text, origin, textParams) {\n        this.title.text = text;\n        this.title.origin = origin;\n        this.title.updateParameters(textParams);\n        this.title.boundingBox.buildPath();\n        this.title.boundingBox.hoverStyle = this.title.boundingBox.clickedStyle = this.title.boundingBox.selectedStyle = this.title.boundingBox.fillStyle;\n        this.title.rowIndices = [];\n    }\n    drawTitle(context, canvasHTMatrix, color) {\n        this.setTitleSettings();\n        const textParams = this.getTitleTextParams(color, this.titleSettings.align, this.titleSettings.baseline, this.titleSettings.orientation);\n        this.updateTitle(context, this.titleText, this.titleSettings.origin.transform(canvasHTMatrix), textParams);\n        this.title.draw(context);\n        this.path.addPath(this.title.path, new DOMMatrix([this.initScale.x, 0, 0, this.initScale.y, 0, 0]));\n    }\n    setTitleSettings() { this.centeredTitle ? this.centeredTitleProperties() : this.topArrowTitleProperties(); }\n    centeredTitleProperties() {\n        this.titleSettings.origin = this.end.add(this.origin).divide(2);\n        this.titleSettings.align = \"center\";\n        this.titleSettings.baseline = ['bottom', 'top'][this.horizontalPickIdx()];\n        if (this.isVertical) {\n            this.titleSettings.origin.x -= this.offsetTitle;\n            this.titleSettings.baseline = ['bottom', 'top'][this.verticalPickIdx()];\n        }\n        else\n            this.titleSettings.origin.y -= this.offsetTitle;\n        this.titleSettings.orientation = this.isVertical ? -90 : 0;\n    }\n    topArrowTitleProperties() {\n        this.titleSettings.origin = this.end.copy();\n        if (this.isVertical) {\n            this.titleSettings.origin.x += _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE;\n            this.titleSettings.align = [\"start\", \"end\"][this.verticalPickIdx()];\n            this.titleSettings.baseline = ['bottom', 'top'][this.horizontalPickIdx()];\n        }\n        else {\n            this.titleSettings.origin.y += _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE;\n            this.titleSettings.align = [\"end\", \"start\"][this.verticalPickIdx()];\n            this.titleSettings.baseline = ['top', 'bottom'][this.horizontalPickIdx()];\n        }\n        this.titleSettings.orientation = 0;\n    }\n    drawTicksPoints(context, pointHTMatrix, color) {\n        const ticksPoints = [];\n        const ticksText = [];\n        const tickTextParams = this.computeTickTextParams();\n        let count = Math.max(0, this.ticks[0]);\n        while (this.labels[count] == '')\n            count++;\n        this.ticks.forEach((tick, idx) => {\n            let point = this.drawTickPoint(context, tick, this.isVertical, pointHTMatrix, color);\n            let text = this.labels[idx];\n            ticksPoints.push(point);\n            if (this.isDiscrete) {\n                if (count == tick && this.labels[count]) {\n                    text = this.labels[count];\n                    count++;\n                }\n                else\n                    text = '';\n            }\n            ticksText.push(this.computeTickText(context, text, tickTextParams, point, pointHTMatrix));\n        });\n        return [ticksPoints, ticksText];\n    }\n    drawTickTexts(ticksTexts, color, context) {\n        this.ticksFontsize = Math.min(...ticksTexts.map(tickText => tickText.fontsize));\n        ticksTexts.forEach(tickText => this.drawTickText(tickText, color, context));\n    }\n    drawTickText(tickText, color, context) {\n        tickText.fillStyle = color;\n        tickText.fontsize = this.ticksFontsize;\n        tickText.draw(context);\n    }\n    computeTickTextParams() {\n        const [textAlign, baseline] = this.textAlignments();\n        let textWidth = null;\n        let textHeight = null;\n        const standardOffset = this.drawLength * 0.95 / this.ticks.length;\n        if (['start', 'end'].includes(textAlign)) {\n            textWidth = this.maxTickWidth;\n            textHeight = standardOffset;\n        }\n        if (textAlign == 'center') {\n            textWidth = standardOffset;\n            textHeight = this.maxTickHeight;\n        }\n        return {\n            width: textWidth, height: textHeight, fontsize: _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE, font: this.font, scale: new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(1, 1),\n            align: textAlign, baseline: baseline, color: this.strokeStyle, backgroundColor: \"hsl(0, 0%, 100%, 0.5)\"\n        };\n    }\n    drawTickPoint(context, tick, vertical, HTMatrix, color) {\n        const center = this.logScale ?\n            new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(Math.log10(tick) * Number(!vertical), Math.log10(tick) * Number(vertical)).transform(HTMatrix) :\n            new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(tick * Number(!vertical), tick * Number(vertical)).transform(HTMatrix);\n        const point = new _primitives__WEBPACK_IMPORTED_MODULE_3__.Point(center.x, center.y, _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END, this.tickMarker, this.tickOrientation, color);\n        point.draw(context);\n        return point;\n    }\n    computeTickText(context, text, tickTextParams, point, HTMatrix) {\n        const textOrigin = this.tickTextPositions(point, HTMatrix);\n        const tickText = new _shapes__WEBPACK_IMPORTED_MODULE_4__.Text(_shapes__WEBPACK_IMPORTED_MODULE_4__.Text.capitalize(text), textOrigin, tickTextParams);\n        tickText.removeEndZeros();\n        tickText.format(context);\n        return tickText;\n    }\n    getValueToDrawMatrix() {\n        let scale = this.drawLength / this.interval;\n        if (this.isInverted) {\n            return new DOMMatrix([\n                -scale, 0, 0, -scale,\n                this.end.x + this.minValue * Number(!this.isVertical) * scale,\n                this.end.y + this.minValue * Number(this.isVertical) * scale\n            ]);\n        }\n        return new DOMMatrix([\n            scale, 0, 0, scale,\n            this.origin.x - this.minValue * Number(!this.isVertical) * scale,\n            this.origin.y - this.minValue * Number(this.isVertical) * scale\n        ]);\n    }\n    marginedBounds(minValue, maxValue) {\n        const valueRange = Math.abs(maxValue - minValue);\n        if (this.isDiscrete)\n            return [minValue - 1, maxValue + 1];\n        return [\n            minValue - valueRange * this.marginRatio,\n            maxValue + valueRange * this.marginRatio\n        ];\n    }\n    updateRubberBand() {\n        const canvasCoords = new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(this.relativeToAbsolute(this.rubberBand.minValue), this.relativeToAbsolute(this.rubberBand.maxValue));\n        this.rubberBand.updateCoords(canvasCoords, this.origin, this.end);\n        [this.rubberBand.origin, this.rubberBand.size] = this.rubberBand.computeRectProperties(this.origin);\n        this.rubberBand.buildPath();\n    }\n    drawRubberBand(context, canvasMatrix) {\n        this.updateRubberBand();\n        context.setTransform(canvasMatrix);\n        this.rubberBand.draw(context);\n        if (this.rubberBand.isClicked)\n            this.emitter.emit(\"rubberBandChange\", this.rubberBand);\n    }\n    mouseTranslate(mouseDown, mouseCoords) { }\n    mouseMoveClickedArrow(mouseCoords) {\n        const mouseDownCoord = this.isVertical ? this.mouseClick.y : this.mouseClick.x;\n        const mouseCurrentCoord = this.isVertical ? mouseCoords.y : mouseCoords.x;\n        if (!this.rubberBand.isClicked)\n            this.rubberBand.updateCoords(new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(mouseDownCoord, mouseCurrentCoord), this.origin, this.end);\n        this.rubberBand.minValue = this.absoluteToRelative(this.rubberBand.canvasMin);\n        this.rubberBand.maxValue = this.absoluteToRelative(this.rubberBand.canvasMax);\n        this.rubberBand.flipMinMax();\n    }\n    mouseMoveClickedTitle(mouseCoords) { }\n    clickOnArrow(mouseDown) {\n        this.is_drawing_rubberband = true; // OLD\n        this.rubberBand.isHovered ? this.rubberBand.mouseDown(mouseDown) : this.rubberBand.reset();\n        this.emitter.emit(\"rubberBandChange\", this.rubberBand);\n    }\n    clickOnDrawnPath(mouseDown) {\n        this.isClicked = true;\n        this.title.isHovered ? this.clickOnTitle(mouseDown) : this.clickOnArrow(mouseDown);\n    }\n    mouseMove(context, mouseCoords) {\n        super.mouseMove(context, mouseCoords);\n        this.boundingBox.mouseMove(context, mouseCoords);\n        this.title.mouseMove(context, mouseCoords.scale(this.initScale));\n        this.rubberBand.mouseMove(context, mouseCoords);\n        if (this.isClicked) {\n            if (this.title.isClicked)\n                this.mouseMoveClickedTitle(mouseCoords);\n            else\n                this.mouseMoveClickedArrow(mouseCoords);\n        }\n    }\n    mouseDown(mouseDown) {\n        super.mouseDown(mouseDown);\n        if (this.isHovered)\n            this.clickOnDrawnPath(mouseDown);\n        if (this.boundingBox.isHovered)\n            this.boundingBox.isClicked = true;\n        this.saveLocation();\n    }\n    mouseUp(keepState) {\n        super.mouseUp(keepState);\n        this.isClicked = false;\n        this.boundingBox.isClicked = false;\n        this.title.mouseUp(false);\n        this.title.isClicked = false;\n        this.rubberBand.mouseUp(keepState);\n        if (this.is_drawing_rubberband)\n            this.emitter.emit(\"rubberBandChange\", this.rubberBand);\n        this.is_drawing_rubberband = false;\n    }\n    clickOnTitle(mouseDown) { this.title.mouseDown(mouseDown); this.title.isClicked = true; }\n    isInRubberBand(value) {\n        return (value >= this.rubberBand.minValue && value <= this.rubberBand.maxValue);\n    }\n    numericLabels() {\n        return this.isDate\n            ? (0,_functions__WEBPACK_IMPORTED_MODULE_1__.formatDateTicks)(this.ticks)\n            : this.ticks.map(tick => tick.toPrecision(this.tickPrecision));\n    }\n    saveLocation() {\n        this._previousMin = this.minValue;\n        this._previousMax = this.maxValue;\n    }\n    stringsToValues(vector) {\n        if (this.isDiscrete)\n            return vector.map(value => this.labels.indexOf(value));\n        return vector;\n    }\n    stringToValue(value) {\n        if (typeof value == 'string')\n            return this.labels.indexOf(value);\n        return value;\n    }\n    textAlignments() {\n        const forVertical = this.initScale.x > 0 ? 'end' : 'start';\n        const forHorizontal = this.initScale.y > 0 ? 'bottom' : 'top';\n        return this.isVertical ? [forVertical, 'middle'] : ['center', forHorizontal];\n    }\n    tickTextPositions(point, HTMatrix) {\n        const origin = point.center;\n        const inversionFactor = this.isInverted ? 1 : -1;\n        if (this.isVertical)\n            origin.x += inversionFactor * Math.sign(HTMatrix.a) * this.offsetTicks;\n        else\n            origin.y += inversionFactor * Math.sign(HTMatrix.d) * this.offsetTicks;\n        return origin;\n    }\n    updateScale(viewPoint, scaling, translation) {\n        const HTMatrix = this.transformMatrix;\n        let center = (viewPoint.x - HTMatrix.e) / HTMatrix.a;\n        ;\n        let offset = translation.x;\n        let scale = this.logScale ? 10 ** (scaling.x - 1) : scaling.x;\n        if (this.isVertical) {\n            center = (viewPoint.y - HTMatrix.f) / HTMatrix.d;\n            offset = translation.y;\n            scale = this.logScale ? 10 ** (scaling.y - 1) : scaling.y;\n        }\n        this.minValue = (this._previousMin - center) / scale + center - offset / HTMatrix.a;\n        this.maxValue = (this._previousMax - center) / scale + center - offset / HTMatrix.a;\n        this.updateTicks();\n    }\n    updateTicks() {\n        this.ticks = this.computeTicks();\n        if (!this.isDiscrete)\n            this.labels = this.numericLabels();\n    }\n}\nclass ParallelAxis extends Axis {\n    constructor(vector, boundingBox, origin, end, name = '', initScale, _nTicks = 10) {\n        super(vector, boundingBox, origin, end, name, initScale, _nTicks);\n        this.boundingBox = boundingBox;\n        this.origin = origin;\n        this.end = end;\n        this.name = name;\n        this.initScale = initScale;\n        this._nTicks = _nTicks;\n        this.titleZone = new _primitives__WEBPACK_IMPORTED_MODULE_3__.Rect();\n        this._hasMoved = false;\n        this.centeredTitle = false;\n        this.updateEnds();\n    }\n    get tickMarker() { return \"line\"; }\n    get tickOrientation() { return this.isVertical ? \"horizontal\" : \"vertical\"; }\n    get hasMoved() { return this._hasMoved; }\n    set hasMoved(value) { this._hasMoved = value; if (this._hasMoved)\n        this.emitter.emit(\"axisStateChange\", this); }\n    updateOffsetTicks() { this.offsetTicks = 10; } // TODO: make it responsive\n    resetScale() {\n        this.isInverted = false;\n        super.resetScale();\n    }\n    setTitleSettings() {\n        this.isVertical ? this.verticalTitleProperties() : this.horizontalTitleProperties();\n    }\n    horizontalTitleProperties() {\n        this.titleSettings.origin.y = this.titleZone.origin.y + this.titleZone.size.y;\n        this.titleSettings.baseline = this.initScale.y > 0 ? \"bottom\" : \"top\";\n        this.titleSettings.orientation = 0;\n    }\n    verticalTitleProperties() {\n        this.titleSettings.baseline = this.initScale.y > 0 ? \"top\" : \"bottom\";\n        this.titleSettings.orientation = 0;\n    }\n    computeTitle(index, nAxis) {\n        this.titleZone = new _primitives__WEBPACK_IMPORTED_MODULE_3__.Rect(this.origin.copy(), this.boundingBox.size.copy());\n        const SIZE_FACTOR = 0.35;\n        let offset = 0;\n        if (this.isVertical) {\n            offset = this.drawLength + Math.min(_constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END * 2, this.drawLength * 0.05);\n            this.titleZone.origin.y += offset;\n        }\n        else {\n            offset = this.offsetTicks + _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE + _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END;\n            if (index != nAxis - 1)\n                this.titleZone.size.x *= SIZE_FACTOR;\n            this.titleZone.size.y = Math.abs(this.boundingBox.origin.y) - Math.abs(this.origin.y);\n            this.titleZone.origin.y -= this.titleZone.size.y;\n        }\n        this.titleZone.size.y -= offset;\n        this.titleZone.buildPath();\n        this.titleSettings.origin = this.titleZone.origin.copy();\n        this.titleSettings.align = this.initScale.x > 0 ? \"left\" : \"right\";\n        if (this.isVertical)\n            this.titleSettings.align = \"center\";\n        return this;\n    }\n    getTitleTextParams(color, align, baseline, orientation) {\n        const titleTextParams = super.getTitleTextParams(color, align, baseline, orientation);\n        titleTextParams.multiLine = true;\n        titleTextParams.width = this.titleZone.size.x;\n        titleTextParams.height = this.titleZone.size.y;\n        return titleTextParams;\n    }\n    computeEnds() {\n        super.computeEnds();\n        if (this.isVertical) {\n            this.end.y -= this.drawLength * 0.1;\n            this.boundingBox.size.x -= _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END / 2;\n        }\n        else\n            this.boundingBox.size.y -= _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END / 2;\n    }\n    mouseMoveClickedTitle(mouseCoords) {\n        const translation = mouseCoords.subtract(this.mouseClick);\n        this.translate(this._previousOrigin.add(translation), this._previousEnd.add(translation));\n        if (translation.norm > 10)\n            this.hasMoved = true;\n    }\n    mouseUp(keepState) {\n        if (this.title.isClicked && this.title.isHovered && !this.hasMoved) {\n            this.title.isClicked = false;\n            this.flip();\n        }\n        if (this.hasMoved)\n            this.updateEnds();\n        this.hasMoved = false;\n        super.mouseUp(keepState);\n    }\n    updateEnds() {\n        this._previousOrigin = this.origin.copy();\n        this._previousEnd = this.end.copy();\n    }\n    flip() {\n        this.isInverted = !this.isInverted;\n        this.rubberBand.isInverted = this.isInverted;\n        this.emitter.emit(\"axisStateChange\", this);\n    }\n    updateLocation(newOrigin, newEnd, boundingBox, index, nAxis) {\n        this.boundingBox = boundingBox;\n        this.transform(newOrigin, newEnd);\n        this.computeEnds();\n        this.adjustBoundingBox();\n        this.updateEnds();\n        this.drawnPath = this.buildArrowPath();\n        this.buildPath();\n        this.computeTitle(index, nAxis);\n    }\n    translate(newOrigin, newEnd) {\n        const translation = newOrigin.subtract(this.origin);\n        this.boundingBox.translate(translation);\n        this.titleSettings.origin = this.titleSettings.origin.add(translation);\n        this.titleZone.origin = this.titleZone.origin.add(translation);\n        this.transform(newOrigin, newEnd);\n    }\n    updateTitle(context, text, origin, textParams) {\n        super.updateTitle(context, text, origin, textParams);\n        const writtenText = this.title.format(context);\n        if (this.isVertical && writtenText.length == 1) {\n            this.titleSettings.align = \"center\";\n            this.titleSettings.origin.x = this.origin.x * this.initScale.x;\n            this.title.origin.x = this.titleSettings.origin.x;\n            this.title.align = \"center\";\n        }\n    }\n    computeTextBoxes(context) {\n        context.save();\n        const [calibratedTickText, calibratedMeasure] = this.getCalibratedTextWidth(context);\n        this.maxTickWidth = this.origin.x - this.boundingBox.origin.x - this.offsetTicks - 3;\n        this.maxTickHeight = Math.min(this.boundingBox.size.y - this.offsetTicks - 3 - _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END / 2, calibratedTickText.fontsize);\n        context.restore();\n    }\n}\n\n\n//# sourceURL=webpack://PlotData/./src/axes.ts?");

/***/ }),

/***/ "./src/baseShape.ts":
/*!**************************!*\
  !*** ./src/baseShape.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InteractiveObject\": () => (/* binding */ InteractiveObject),\n/* harmony export */   \"Shape\": () => (/* binding */ Shape),\n/* harmony export */   \"Vertex\": () => (/* binding */ Vertex)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles */ \"./src/styles.ts\");\n\n\n\nclass Vertex {\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    get coordinates() { return [this.x, this.y]; }\n    get normL1() { return Math.abs(this.x) + Math.abs(this.y); }\n    get norm() { return (this.x ** 2 + this.y ** 2) ** 0.5; }\n    get min() { return Math.min(this.x, this.y); }\n    get max() { return Math.max(this.x, this.y); }\n    copy() { return new Vertex(this.x, this.y); }\n    add(other) {\n        let copy = this.copy();\n        copy.x = this.x + other.x;\n        copy.y = this.y + other.y;\n        return copy;\n    }\n    divide(value) {\n        let copy = this.copy();\n        copy.x = this.x / value;\n        copy.y = this.y / value;\n        return copy;\n    }\n    multiply(value) {\n        let copy = this.copy();\n        copy.x = this.x * value;\n        copy.y = this.y * value;\n        return copy;\n    }\n    distance(other) { return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2); }\n    scale(scale) {\n        let copy = this.copy();\n        copy.x = this.x * scale.x;\n        copy.y = this.y * scale.y;\n        return copy;\n    }\n    translate(translation) { return this.add(translation); }\n    translateSelf(translation) {\n        this.x += translation.x;\n        this.y += translation.y;\n    }\n    subtract(other) {\n        let copy = this.copy();\n        copy.x = this.x - other.x;\n        copy.y = this.y - other.y;\n        return copy;\n    }\n    transform(matrix) {\n        let copy = this.copy();\n        copy.x = matrix.a * this.x + matrix.c * this.y + matrix.e;\n        copy.y = matrix.b * this.x + matrix.d * this.y + matrix.f;\n        return copy;\n    }\n    transformSelf(matrix) {\n        this.x = matrix.a * this.x + matrix.c * this.y + matrix.e;\n        this.y = matrix.b * this.x + matrix.d * this.y + matrix.f;\n    }\n}\nclass InteractiveObject {\n    constructor() {\n        this.path = new Path2D();\n        this.drawnPath = new Path2D();\n        this.inStrokeScale = new Vertex(1, 1);\n        this.mouseClick = null;\n        this.isHovered = false;\n        this.isClicked = false;\n        this.isSelected = false;\n        this.isScaled = true;\n        this.isFilled = true;\n        this.visible = true;\n        this.inFrame = true; // TODO: remove it\n    }\n    ;\n    getBounds() { return [new Vertex(0, 1), new Vertex(0, 1)]; }\n    updateTooltipOrigin(matrix) { }\n    buildPath() { }\n    buildScaledPath(context, contextMatrix) {\n        this.drawnPath.addPath(this.path, new DOMMatrix().scale(contextMatrix.a, contextMatrix.d));\n        context.scale(1 / contextMatrix.a, 1 / contextMatrix.d);\n        this.inStrokeScale = new Vertex(1 / contextMatrix.a, 1 / contextMatrix.d);\n    }\n    buildUnscaledPath(context) {\n        context.resetTransform();\n        return this.path;\n    }\n    buildDrawPath(context) {\n        const contextMatrix = context.getTransform();\n        this.drawnPath = new Path2D();\n        this.updateTooltipOrigin(contextMatrix);\n        if (this.isScaled)\n            this.buildScaledPath(context, contextMatrix);\n        else\n            this.drawnPath.addPath(this.buildUnscaledPath(context));\n    }\n    drawPath(context) {\n        if (this.isFilled)\n            context.fill(this.drawnPath);\n        context.stroke(this.drawnPath);\n    }\n    drawMembers(context) { }\n    computeContextualAttributes(context) { }\n    setDrawingProperties(context) { }\n    draw(context) {\n        if (this.visible) {\n            context.save();\n            this.computeContextualAttributes(context);\n            this.buildDrawPath(context);\n            this.setDrawingProperties(context);\n            this.drawPath(context);\n            context.restore();\n            this.drawMembers(context);\n        }\n    }\n    isPointInShape(context, point) {\n        if (this.isFilled)\n            return context.isPointInPath(this.path, point.x, point.y);\n        return this.isPointInStroke(context, point);\n    }\n    isPointInStroke(context, point) {\n        let isHovered;\n        const contextMatrix = context.getTransform();\n        const contextLineWidth = context.lineWidth;\n        context.lineWidth = 10;\n        if (this.isScaled) {\n            context.scale(this.inStrokeScale.x, this.inStrokeScale.y);\n            isHovered = context.isPointInStroke(this.drawnPath, point.x, point.y);\n        }\n        else\n            isHovered = context.isPointInStroke(this.path, point.x, point.y);\n        context.setTransform(contextMatrix);\n        context.lineWidth = contextLineWidth;\n        return isHovered;\n    }\n    mouseDown(mouseDown) { if (this.isHovered)\n        this.mouseClick = mouseDown.copy(); }\n    mouseMove(context, mouseCoords) { this.isHovered = this.isPointInShape(context, mouseCoords); }\n    mouseUp(keepState) {\n        this.isClicked = this.isHovered ? !this.isClicked : (keepState ? this.isClicked : false);\n    }\n}\nclass Shape extends InteractiveObject {\n    constructor() {\n        super();\n        this.lineWidth = 1;\n        this.dashLine = [];\n        this.hatching = null;\n        this.strokeStyle = null;\n        this.fillStyle = _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SHAPE_COLOR;\n        this.hoverStyle = _constants__WEBPACK_IMPORTED_MODULE_0__.HOVERED_SHAPE_COLOR;\n        this.clickedStyle = _constants__WEBPACK_IMPORTED_MODULE_0__.CLICKED_SHAPE_COLOR;\n        this.selectedStyle = _constants__WEBPACK_IMPORTED_MODULE_0__.SELECTED_SHAPE_COLOR;\n        this.alpha = 1;\n        this.tooltipOrigin = null;\n        this._tooltipMap = new Map();\n        this.hasTooltip = true;\n    }\n    ;\n    get tooltipMap() { return this._tooltipMap; }\n    set tooltipMap(value) { this._tooltipMap = value; }\n    get tooltipFlip() { return false; }\n    get drawingStyle() {\n        const style = {};\n        style[\"lineWidth\"] = this.lineWidth;\n        style[\"dashLine\"] = this.dashLine;\n        style[\"hatching\"] = this.hatching;\n        style[\"strokeStyle\"] = this.strokeStyle;\n        style[\"fillStyle\"] = this.fillStyle;\n        style[\"alpha\"] = this.alpha;\n        return style;\n    }\n    deserializeStyle(data) {\n        this.deserializeEdgeStyle(data);\n        this.deserializeSurfaceStyle(data);\n        this.deserializeTooltip(data);\n    }\n    deserializeEdgeStyle(data) {\n        var _a, _b, _c, _d, _e;\n        this.lineWidth = (_b = (_a = data.edge_style) === null || _a === void 0 ? void 0 : _a.line_width) !== null && _b !== void 0 ? _b : this.lineWidth;\n        this.dashLine = (_d = (_c = data.edge_style) === null || _c === void 0 ? void 0 : _c.dashline) !== null && _d !== void 0 ? _d : this.dashLine;\n        this.strokeStyle = ((_e = data.edge_style) === null || _e === void 0 ? void 0 : _e.color_stroke) ? (0,_colors__WEBPACK_IMPORTED_MODULE_1__.colorHsl)(data.edge_style.color_stroke) : null;\n    }\n    deserializeSurfaceStyle(data) {\n        var _a, _b, _c, _d, _e;\n        this.fillStyle = (0,_colors__WEBPACK_IMPORTED_MODULE_1__.colorHsl)((_b = (_a = data.surface_style) === null || _a === void 0 ? void 0 : _a.color_fill) !== null && _b !== void 0 ? _b : this.fillStyle);\n        this.alpha = (_d = (_c = data.surface_style) === null || _c === void 0 ? void 0 : _c.opacity) !== null && _d !== void 0 ? _d : this.alpha;\n        this.hatching = ((_e = data.surface_style) === null || _e === void 0 ? void 0 : _e.hatching) ? new _styles__WEBPACK_IMPORTED_MODULE_2__.Hatching(\"\", data.surface_style.hatching.stroke_width, data.surface_style.hatching.hatch_spacing) : null;\n    }\n    deserializeTooltip(data) { if (data.tooltip)\n        this.tooltipMap.set(data.tooltip, \"\"); }\n    newTooltipMap() { this._tooltipMap = new Map(); }\n    initTooltipOrigin() { }\n    updateTooltipOrigin(matrix) {\n        if (this.mouseClick)\n            this.tooltipOrigin = this.mouseClick.transform(matrix);\n    }\n    setStrokeStyle(fillStyle) {\n        const [h, s, l] = (0,_colors__WEBPACK_IMPORTED_MODULE_1__.hslToArray)((0,_colors__WEBPACK_IMPORTED_MODULE_1__.colorHsl)(fillStyle));\n        const lValue = l <= _constants__WEBPACK_IMPORTED_MODULE_0__.STROKE_STYLE_OFFSET ? l + _constants__WEBPACK_IMPORTED_MODULE_0__.STROKE_STYLE_OFFSET : l - _constants__WEBPACK_IMPORTED_MODULE_0__.STROKE_STYLE_OFFSET;\n        return `hsl(${h}, ${s}%, ${lValue}%)`;\n    }\n    setContextFillStyle(context) {\n        context.fillStyle = this.isHovered\n            ? this.hoverStyle\n            : this.isClicked\n                ? this.clickedStyle\n                : this.isSelected\n                    ? this.selectedStyle\n                    : this.fillStyle;\n    }\n    setContextFilledStrokeStyle(context) {\n        const fillStyle = context.fillStyle.toString();\n        context.strokeStyle = (this.isHovered || this.isClicked || this.isSelected)\n            ? this.setStrokeStyle(fillStyle)\n            : this.strokeStyle\n                ? (0,_colors__WEBPACK_IMPORTED_MODULE_1__.colorHsl)(this.strokeStyle)\n                : this.setStrokeStyle(fillStyle);\n    }\n    setContextEmptyStyle(context) {\n        context.strokeStyle = this.isHovered\n            ? this.hoverStyle\n            : this.isClicked\n                ? this.clickedStyle\n                : this.isSelected\n                    ? this.selectedStyle\n                    : this.strokeStyle\n                        ? (0,_colors__WEBPACK_IMPORTED_MODULE_1__.colorHsl)(this.strokeStyle)\n                        : 'hsl(0, 0%, 0%)';\n    }\n    setContextHatch(context) {\n        if (this.hatching)\n            context.fillStyle = context.createPattern(this.hatching.buildTexture(context.fillStyle.toString()), 'repeat');\n    }\n    setContextFilledStyle(context) {\n        this.setContextFillStyle(context);\n        this.setContextFilledStrokeStyle(context);\n        this.setContextHatch(context);\n    }\n    setContextStyle(context) {\n        if (this.isFilled)\n            this.setContextFilledStyle(context);\n        else\n            this.setContextEmptyStyle(context);\n    }\n    alphaConfiguration(context) {\n        if (this.alpha == 0)\n            this.isFilled = false;\n        else if (this.alpha != 1)\n            context.globalAlpha = this.alpha;\n    }\n    setDrawingProperties(context) {\n        context.lineWidth = this.lineWidth;\n        context.setLineDash(this.dashLine);\n        this.alphaConfiguration(context);\n        this.setContextStyle(context);\n    }\n}\n\n\n//# sourceURL=webpack://PlotData/./src/baseShape.ts?");

/***/ }),

/***/ "./src/collections.ts":
/*!****************************!*\
  !*** ./src/collections.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GroupCollection\": () => (/* binding */ GroupCollection),\n/* harmony export */   \"PointSet\": () => (/* binding */ PointSet),\n/* harmony export */   \"SelectionBoxCollection\": () => (/* binding */ SelectionBoxCollection),\n/* harmony export */   \"ShapeCollection\": () => (/* binding */ ShapeCollection)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n/* harmony import */ var _baseShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./baseShape */ \"./src/baseShape.ts\");\n/* harmony import */ var _primitives__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./primitives */ \"./src/primitives.ts\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shapes */ \"./src/shapes.ts\");\n/* harmony import */ var _shapeFunctions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shapeFunctions */ \"./src/shapeFunctions.ts\");\n\n\n\n\n\n\nclass PointSet {\n    constructor(indices = [], color = \"hsl(32, 100%, 50%)\", name = \"\") {\n        this.indices = indices;\n        this.name = name;\n        this.color = (0,_colors__WEBPACK_IMPORTED_MODULE_1__.colorHsl)(color);\n    }\n    includes(pointIndex) { return this.indices.includes(pointIndex); }\n    indexOf(pointIndex) { return this.indices.indexOf(pointIndex); }\n}\nclass ShapeCollection {\n    constructor(shapes = []) {\n        this.shapes = shapes;\n        [this.minimum, this.maximum] = this.getBounds();\n    }\n    get length() { return this.shapes.length; }\n    includes(shape) { return this.shapes.includes(shape); }\n    static fromPrimitives(primitives, scale = new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(1, 1)) {\n        return new ShapeCollection(primitives.map(primitive => (0,_shapeFunctions__WEBPACK_IMPORTED_MODULE_5__.deserialize)(primitive, scale)));\n    }\n    getBounds() {\n        let minimum = new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        let maximum = new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n        this.shapes.forEach(shape => {\n            const [shapeMin, shapeMax] = shape.getBounds();\n            if (shapeMin.x <= minimum.x)\n                minimum.x = shapeMin.x; //for NaN reasons, must change\n            if (shapeMin.y <= minimum.y)\n                minimum.y = shapeMin.y;\n            if (shapeMax.x >= maximum.x)\n                maximum.x = shapeMax.x;\n            if (shapeMax.y >= maximum.y)\n                maximum.y = shapeMax.y;\n        });\n        return [minimum, maximum];\n    }\n    drawTooltips(canvasOrigin, canvasSize, context, inMultiPlot) {\n        this.shapes.forEach(shape => { if (!inMultiPlot && shape.inFrame)\n            (0,_shapeFunctions__WEBPACK_IMPORTED_MODULE_5__.drawTooltip)(shape, canvasOrigin, canvasSize, context); });\n    }\n    mouseMove(context, mouseCoords) {\n        this.shapes.forEach(shape => shape.mouseMove(context, mouseCoords));\n    }\n    mouseDown(mouseCoords) {\n        let clickedObject = null;\n        this.shapes.forEach(shape => {\n            shape.mouseDown(mouseCoords);\n            if (shape.isHovered)\n                clickedObject = shape; //TODO: still insane ?\n        });\n        return clickedObject;\n    }\n    mouseUp(keepState) { this.shapes.forEach(shape => shape.mouseUp(keepState)); }\n    draw(context) { this.shapes.forEach(shape => shape.draw(context)); }\n    removeShape(index) {\n        this.shapes.splice(index, 1);\n        [this.minimum, this.maximum] = this.getBounds();\n    }\n    updateBounds(context) {\n        this.shapes.forEach(shape => {\n            if (shape instanceof _shapes__WEBPACK_IMPORTED_MODULE_4__.Text) {\n                shape.format(context);\n                shape.updateBoundingBox(context);\n                const [textMin, textMax] = shape.getBounds();\n                this.minimum.x = Math.min(this.minimum.x, textMin.x);\n                this.minimum.y = Math.min(this.minimum.y, textMin.y);\n                this.maximum.x = Math.max(this.maximum.x, textMax.x);\n                this.maximum.y = Math.max(this.maximum.y, textMax.y);\n            }\n        });\n        if (Number.isNaN(this.minimum.x))\n            this.minimum.x = this.maximum.x - 1;\n        if (Number.isNaN(this.minimum.y))\n            this.minimum.y = this.maximum.y - 1;\n        if (Number.isNaN(this.maximum.x))\n            this.maximum.x = this.maximum.x + 1;\n        if (Number.isNaN(this.maximum.y))\n            this.maximum.y = this.maximum.y + 1;\n    }\n    updateShapeStates(stateName) {\n        const newStates = [];\n        this.shapes.forEach((shape, index) => {\n            if (shape[stateName] && !(shape instanceof _shapes__WEBPACK_IMPORTED_MODULE_4__.SelectionBox))\n                newStates.push(index);\n        });\n        return newStates;\n    }\n    resetShapeStates() {\n        this.shapes.forEach(shape => shape.isHovered = shape.isClicked = shape.isSelected = false);\n    }\n    locateLabels(drawingZone, initScale) {\n        const nLabels = 0.5 * initScale.y;\n        const labels = [];\n        const others = [];\n        this.shapes.forEach(shape => {\n            if (shape instanceof _shapes__WEBPACK_IMPORTED_MODULE_4__.Label)\n                labels.push(shape);\n            else\n                others.push(shape);\n        });\n        if (labels.length != 0) {\n            const labelHeight = Math.min(Math.abs(drawingZone.size.y) / (labels.length * 1.75 + 1), _constants__WEBPACK_IMPORTED_MODULE_0__.MAX_LABEL_HEIGHT);\n            labels.forEach((label, index) => {\n                label.updateHeight(labelHeight);\n                label.updateOrigin(drawingZone, initScale, index - nLabels);\n            });\n        }\n        this.shapes = [...others, ...labels];\n    }\n}\nclass SelectionBoxCollection extends ShapeCollection {\n    constructor(shapes = []) {\n        super(shapes);\n        this.shapes = shapes;\n    }\n}\nclass GroupCollection extends ShapeCollection {\n    constructor(shapes = []) {\n        super(shapes);\n        this.shapes = shapes;\n    }\n    shapeIsContainer(shape) { var _a; return ((_a = shape.values) === null || _a === void 0 ? void 0 : _a.length) > 1 || shape instanceof _primitives__WEBPACK_IMPORTED_MODULE_3__.LineSequence; }\n    drawTooltips(canvasOrigin, canvasSize, context, inMultiPlot) {\n        this.shapes.forEach(shape => { if ((this.shapeIsContainer(shape) || !inMultiPlot) && shape.inFrame)\n            (0,_shapeFunctions__WEBPACK_IMPORTED_MODULE_5__.drawTooltip)(shape, canvasOrigin, canvasSize, context); });\n    }\n    updateShapeStates(stateName) {\n        const ShapeStates = [];\n        this.shapes.forEach((shape, index) => {\n            if (shape.values) {\n                if (shape[stateName])\n                    shape.values.forEach(sample => ShapeStates.push(sample));\n            }\n            else {\n                if (shape[stateName] && !(shape instanceof _shapes__WEBPACK_IMPORTED_MODULE_4__.SelectionBox))\n                    ShapeStates.push(index);\n            }\n        });\n        return ShapeStates;\n    }\n}\n\n\n//# sourceURL=webpack://PlotData/./src/collections.ts?");

/***/ }),

/***/ "./src/colors.ts":
/*!***********************!*\
  !*** ./src/colors.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arrayHexToHsl\": () => (/* binding */ arrayHexToHsl),\n/* harmony export */   \"arrayHexToRgb\": () => (/* binding */ arrayHexToRgb),\n/* harmony export */   \"arrayHslToHex\": () => (/* binding */ arrayHslToHex),\n/* harmony export */   \"arrayHslToRgb\": () => (/* binding */ arrayHslToRgb),\n/* harmony export */   \"arrayRgbToHex\": () => (/* binding */ arrayRgbToHex),\n/* harmony export */   \"arrayRgbToHsl\": () => (/* binding */ arrayRgbToHsl),\n/* harmony export */   \"colorHex\": () => (/* binding */ colorHex),\n/* harmony export */   \"colorHsl\": () => (/* binding */ colorHsl),\n/* harmony export */   \"colorRgb\": () => (/* binding */ colorRgb),\n/* harmony export */   \"componentToHex\": () => (/* binding */ componentToHex),\n/* harmony export */   \"hexToHsl\": () => (/* binding */ hexToHsl),\n/* harmony export */   \"hexToRgb\": () => (/* binding */ hexToRgb),\n/* harmony export */   \"hslToArray\": () => (/* binding */ hslToArray),\n/* harmony export */   \"hslToHex\": () => (/* binding */ hslToHex),\n/* harmony export */   \"hslToRgb\": () => (/* binding */ hslToRgb),\n/* harmony export */   \"hslToString\": () => (/* binding */ hslToString),\n/* harmony export */   \"rgbToArray\": () => (/* binding */ rgbToArray),\n/* harmony export */   \"rgbToHex\": () => (/* binding */ rgbToHex),\n/* harmony export */   \"rgbToHsl\": () => (/* binding */ rgbToHsl),\n/* harmony export */   \"rgbToString\": () => (/* binding */ rgbToString),\n/* harmony export */   \"string_to_hex\": () => (/* binding */ string_to_hex),\n/* harmony export */   \"string_to_hex_dict\": () => (/* binding */ string_to_hex_dict)\n/* harmony export */ });\n/* OLD: For frontend to work correctly */\nfunction string_to_hex(str) {\n    if (!Object.keys(string_to_hex_dict).includes(str)) {\n        throw new Error('string_to_hex -> Invalid color : ' + str + ' not in list');\n    }\n    return string_to_hex_dict[str];\n}\nconst string_to_hex_dict = {\n    red: '#f70000', lightred: '#ed8080', blue: '#0013fe', lightblue: '#c3e6fc', lightskyblue: '#87cefa', green: '#00c112', lightgreen: '#89e892', yellow: '#f4ff00', lightyellow: '#f9ff7b', orange: '#ff8700',\n    lightorange: '#ff8700', cyan: '#13f0f0', lightcyan: '#90f7f7', rose: '#ff69b4', lightrose: '#ffc0cb', violet: '#ee82ee', lightviolet: '#eaa5f6', white: '#ffffff', black: '#000000', brown: '#cd8f40',\n    lightbrown: '#deb887', grey: '#a9a9a9', lightgrey: '#d3d3d3'\n};\n// NEW\nfunction arrayRgbToHsl(r, g, b) {\n    // Get [h,s,l] array of HSL color from [r,g,b] array from a RGB color array.\n    // HSL and RGB theory https://www.rapidtables.com/convert/color/rgb-to-hsl.html\n    let normedR = r / 255;\n    let normedG = g / 255;\n    let normedB = b / 255;\n    const cMax = Math.max(normedR, normedG, normedB);\n    const cMin = Math.min(normedR, normedG, normedB);\n    const delta = cMax - cMin;\n    const l = (cMax + cMin) / 2;\n    let h = 0;\n    let s = 0;\n    if (delta != 0) {\n        if (cMax == normedR)\n            h = 60 * (normedG - normedB) / delta;\n        else if (cMax == normedG)\n            h = 60 * ((normedB - normedR) / delta + 2);\n        else\n            h = 60 * ((normedR - normedG) / delta + 4);\n        if (h < 0)\n            h += 360;\n        s = delta / (1 - Math.abs(2 * l - 1));\n    }\n    return [h, s * 100, l * 100];\n}\n;\nfunction arrayHslToRgb(h, s, l) {\n    /*\n    Get [r,g,b] array of RGB color from [h,s,l] array from a HSL color array.\n  \n    The k function is used to determine which of the six segments of the color wheel the current hue falls within,\n    and then adjusts the lightness value l based on the saturation and hue values.\n    The a variable is used to compute the amount of lightness to be added or subtracted from the lightness value\n    based on the saturation value.\n    Finally, the f function is used to compute the RGB values for each of the three color channels\n    (red (0), green (8), and blue (4)) based on the k function and the a variable.\n    The f function returns a value between 0 and 1, which is then scaled up to the appropriate range to represent an RGB\n    color value.\n  \n    Source: https://www.rapidtables.com/convert/color/hsl-to-rgb.html\n    */\n    s /= 100;\n    l /= 100;\n    const k = n => (n + h / 30) % 12;\n    const a = s * Math.min(l, 1 - l);\n    const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1))); //\n    return [255 * f(0), 255 * f(8), 255 * f(4)];\n}\nfunction hslToArray(hslColor) {\n    // Get [h,s,l] array from a HSL color (format: hsl(h,s%,l%)).\n    let [h, s, l] = hslColor.split(',');\n    return [Number(h.split('hsl(')[1]), Number(s.split('%')[0]), Number(l.split('%')[0])];\n}\nfunction rgbToArray(rgbColor) {\n    // Get [r,g,b] array from a RGB color (format: rgb(r,g,b)).\n    let [r, g, b] = rgbColor.split(',');\n    return [Number(r.split('rgb(')[1]), Number(g), Number(b.split(\")\")[0])];\n}\nfunction componentToHex(component) {\n    // Get hexadecimal code of a rgb component.\n    // RGB and HEX theory: https://www.rapidtables.com/convert/color/hex-to-rgb.html\n    var hex = component.toString(16);\n    return hex.length == 1 ? \"0\" + hex : hex;\n}\nfunction arrayRgbToHex(r, g, b) {\n    // Get a Hexadecimal color (format: #RRGGBB with RR, GG, BB in hexadecimal format) from RGB color (rgb(r,g,b)) vector.\n    // RGB and HEX theory: https://www.rapidtables.com/convert/color/hex-to-rgb.html\n    return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\nfunction arrayHexToRgb(hexColor) {\n    // Get RGB color (rgb(r,g,b)) vector from a Hexadecimal color (format: #RRGGBB with RR, GG, BB in hexadecimal format).\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hexColor);\n    return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;\n}\nfunction arrayHslToHex(h, s, l) {\n    /*\n    Lightness is normalized before any computation, so is saturation.\n    The function first calculates the amount of saturation that should be added to the lightness value to create the equivalent\n    amount of color. The Math.min() function is used to ensure that the saturation value is not greater than 50%.\n  \n    The f function then takes a number as input and calculates the corresponding color value based on the input value and\n    the HSL color values.\n    The k variable converts the input value (0 for red, 8 for green, 4 for blue) to get the corresponding color.\n    The color is then calculated with k, l and some magic numbers.\n  \n    The reason for using these numbers (3, 9) in this calculation is because the HSL color model uses a circular color wheel.\n    By using 3 and 9 as the modulo values, we ensure that the input value is always within the range of 0 to 11, which\n    corresponds to the red, green, and blue colors on the color wheel.\n  \n    The f function is called three times with different input values to calculate the red, green, and blue color values.\n    The resulting red, green, and blue values are concatenated into a single hexadecimal color value in the format #RRGGBB.\n  \n    Source:  https://docs.aspose.com/html/net/tutorial/html-colors/\n    */\n    l /= 100;\n    const a = s * Math.min(l, 1 - l) / 100;\n    const f = n => {\n        const k = (n + h / 30) % 12;\n        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n        return Math.round(255 * color).toString(16).padStart(2, '0'); // convert to Hex and prefix \"0\" if needed\n    };\n    return `#${f(0)}${f(8)}${f(4)}`;\n}\nfunction arrayHexToHsl(hexColor) { return arrayRgbToHsl(...arrayHexToRgb(hexColor)); }\nfunction rgbToString(r, g, b) { return `rgb(${r},${g},${b})`; }\nfunction hslToString(h, s, l) { return `hsl(${h},${s}%,${l}%)`; }\nfunction hslToRgb(hslColor) { return rgbToString(...arrayHslToRgb(...hslToArray(hslColor))); }\nfunction rgbToHsl(rgbColor) { return hslToString(...arrayRgbToHsl(...rgbToArray(rgbColor))); }\nfunction rgbToHex(rgbColor) { return arrayRgbToHex(...rgbToArray(rgbColor)); }\nfunction hexToRgb(hexColor) { return rgbToString(...arrayHexToRgb(hexColor)); }\nfunction hexToHsl(hexColor) { return hslToString(...arrayHexToHsl(hexColor)); }\nfunction hslToHex(hslColor) { return arrayHslToHex(...hslToArray(hslColor)); }\nfunction colorHsl(color) {\n    if (color.includes('hsl'))\n        return color;\n    if (color.includes('rgb'))\n        return rgbToHsl(color);\n    if (color.includes('#'))\n        return hexToHsl(color);\n    throw new Error(`${color} is not a color.`);\n}\nfunction colorHex(color) {\n    if (color.includes('#'))\n        return color;\n    if (color.includes('hsl'))\n        return hslToHex(color);\n    if (color.includes('rgb'))\n        return rgbToHex(color);\n    throw new Error(`${color} is not a color.`);\n}\nfunction colorRgb(color) {\n    if (color.includes('rgb'))\n        return color;\n    if (color.includes('hsl'))\n        return hslToRgb(color);\n    if (color.includes('#'))\n        return hexToRgb(color);\n    throw new Error(`${color} is not a color.`);\n}\n\n\n//# sourceURL=webpack://PlotData/./src/colors.ts?");

/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AXES_BLANK_SPACE\": () => (/* binding */ AXES_BLANK_SPACE),\n/* harmony export */   \"AXIS_TAIL_SIZE\": () => (/* binding */ AXIS_TAIL_SIZE),\n/* harmony export */   \"CIRCLES\": () => (/* binding */ CIRCLES),\n/* harmony export */   \"CLICKED_SHAPE_COLOR\": () => (/* binding */ CLICKED_SHAPE_COLOR),\n/* harmony export */   \"CROSSES\": () => (/* binding */ CROSSES),\n/* harmony export */   \"DASH_SELECTION_WINDOW\": () => (/* binding */ DASH_SELECTION_WINDOW),\n/* harmony export */   \"DEFAULT_FONTSIZE\": () => (/* binding */ DEFAULT_FONTSIZE),\n/* harmony export */   \"DEFAULT_SHAPE_COLOR\": () => (/* binding */ DEFAULT_SHAPE_COLOR),\n/* harmony export */   \"DRAW_MARGIN_FACTOR\": () => (/* binding */ DRAW_MARGIN_FACTOR),\n/* harmony export */   \"EMPTY_MULTIPLOT\": () => (/* binding */ EMPTY_MULTIPLOT),\n/* harmony export */   \"FIGURES_BLANK_SPACE\": () => (/* binding */ FIGURES_BLANK_SPACE),\n/* harmony export */   \"FREE_SPACE_FACTOR\": () => (/* binding */ FREE_SPACE_FACTOR),\n/* harmony export */   \"HALF_LINES\": () => (/* binding */ HALF_LINES),\n/* harmony export */   \"HOVERED_SHAPE_COLOR\": () => (/* binding */ HOVERED_SHAPE_COLOR),\n/* harmony export */   \"INFINITE_LINE_FACTOR\": () => (/* binding */ INFINITE_LINE_FACTOR),\n/* harmony export */   \"LABEL_TEXT_OFFSET\": () => (/* binding */ LABEL_TEXT_OFFSET),\n/* harmony export */   \"LEGEND_MARGIN\": () => (/* binding */ LEGEND_MARGIN),\n/* harmony export */   \"MARKERS\": () => (/* binding */ MARKERS),\n/* harmony export */   \"MAX_LABEL_HEIGHT\": () => (/* binding */ MAX_LABEL_HEIGHT),\n/* harmony export */   \"MIN_OFFSET_X\": () => (/* binding */ MIN_OFFSET_X),\n/* harmony export */   \"MIN_OFFSET_Y\": () => (/* binding */ MIN_OFFSET_Y),\n/* harmony export */   \"PG_CONTAINER_PLOT\": () => (/* binding */ PG_CONTAINER_PLOT),\n/* harmony export */   \"PICKABLE_BORDER_SIZE\": () => (/* binding */ PICKABLE_BORDER_SIZE),\n/* harmony export */   \"REGEX_SAMPLES\": () => (/* binding */ REGEX_SAMPLES),\n/* harmony export */   \"RUBBERBAND_SMALL_SIZE\": () => (/* binding */ RUBBERBAND_SMALL_SIZE),\n/* harmony export */   \"SELECTED_SHAPE_COLOR\": () => (/* binding */ SELECTED_SHAPE_COLOR),\n/* harmony export */   \"SIZE_AXIS_END\": () => (/* binding */ SIZE_AXIS_END),\n/* harmony export */   \"SQUARES\": () => (/* binding */ SQUARES),\n/* harmony export */   \"STROKE_STYLE_OFFSET\": () => (/* binding */ STROKE_STYLE_OFFSET),\n/* harmony export */   \"TEXT_SEPARATORS\": () => (/* binding */ TEXT_SEPARATORS),\n/* harmony export */   \"TOOLTIP_PRECISION\": () => (/* binding */ TOOLTIP_PRECISION),\n/* harmony export */   \"TOOLTIP_TEXT_OFFSET\": () => (/* binding */ TOOLTIP_TEXT_OFFSET),\n/* harmony export */   \"TOOLTIP_TRIANGLE_SIZE\": () => (/* binding */ TOOLTIP_TRIANGLE_SIZE),\n/* harmony export */   \"TRIANGLES\": () => (/* binding */ TRIANGLES),\n/* harmony export */   \"ZOOM_FACTOR\": () => (/* binding */ ZOOM_FACTOR)\n/* harmony export */ });\nconst PICKABLE_BORDER_SIZE = 20;\nconst RUBBERBAND_SMALL_SIZE = 10;\nconst DASH_SELECTION_WINDOW = [7, 3];\nconst AXIS_TAIL_SIZE = 0;\nconst INFINITE_LINE_FACTOR = 1e3;\nconst SIZE_AXIS_END = 7;\nconst MAX_LABEL_HEIGHT = 12;\nconst AXES_BLANK_SPACE = 3;\nconst FIGURES_BLANK_SPACE = 4;\nconst LEGEND_MARGIN = 2;\nconst ZOOM_FACTOR = 1.2;\nconst MIN_OFFSET_X = 33;\nconst MIN_OFFSET_Y = 6;\nconst DEFAULT_FONTSIZE = 12;\nconst FREE_SPACE_FACTOR = 0.95;\nconst DRAW_MARGIN_FACTOR = 0.025;\nconst DEFAULT_SHAPE_COLOR = 'hsl(203, 90%, 85%)';\nconst HOVERED_SHAPE_COLOR = 'hsl(203, 90%, 60%)';\nconst CLICKED_SHAPE_COLOR = 'hsl(203, 90%, 35%)';\nconst SELECTED_SHAPE_COLOR = 'hsl(140, 65%, 60%)';\nconst STROKE_STYLE_OFFSET = 15;\nconst TEXT_SEPARATORS = [\"_\", \"/\", \"\\\\\", \" \", \",\", \";\", \":\", \"!\", \"?\", \")\", \"(\", \"{\", \"}\", \"[\", \"]\", \"=\", \"+\", \"-\"];\nconst TOOLTIP_PRECISION = 100;\nconst TOOLTIP_TEXT_OFFSET = 10;\nconst TOOLTIP_TRIANGLE_SIZE = 10;\nconst CIRCLES = ['o', 'circle', 'round'];\nconst MARKERS = ['+', 'crux', 'mark'];\nconst CROSSES = ['x', 'cross', 'oblique'];\nconst SQUARES = ['square'];\nconst TRIANGLES = ['^', 'triangle', 'tri'];\nconst HALF_LINES = ['halfLine', 'halfline'];\nconst LABEL_TEXT_OFFSET = 5;\nconst REGEX_SAMPLES = /^[0-9]+\\ssamples/;\nconst PG_CONTAINER_PLOT = {\n    \"name\": \"\",\n    \"primitives\": [\n        {\n            \"name\": \"\",\n            \"comment\": \"PrimitiveGroupContainer is not supported anymore in plot_data 0.19.0 and further versions.\",\n            \"text_style\": {\n                \"object_class\": \"plot_data.core.TextStyle\",\n                \"name\": \"\",\n                \"text_color\": \"rgb(100, 100, 100)\",\n                \"font_size\": 16,\n                \"text_align_x\": \"center\",\n                \"text_align_y\": \"middle\"\n            },\n            \"position_x\": 50.0,\n            \"position_y\": 100,\n            \"text_scaling\": false,\n            \"max_width\": 250,\n            \"multi_lines\": true,\n            \"type_\": \"text\"\n        }\n    ],\n    \"type_\": \"primitivegroup\"\n};\nconst EMPTY_MULTIPLOT = {\n    \"name\": \"\",\n    \"primitives\": [\n        {\n            \"name\": \"\",\n            \"comment\": \"No plot defined in multiplot so there is nothing to draw.\",\n            \"text_style\": {\n                \"object_class\": \"plot_data.core.TextStyle\",\n                \"name\": \"\",\n                \"text_color\": \"rgb(100, 100, 100)\",\n                \"font_size\": 20,\n                \"text_align_x\": \"left\"\n            },\n            \"position_x\": 50.0,\n            \"position_y\": 100,\n            \"text_scaling\": false,\n            \"max_width\": 400,\n            \"multi_lines\": true,\n            \"type_\": \"text\"\n        }\n    ],\n    \"type_\": \"primitivegroup\"\n};\n\n\n//# sourceURL=webpack://PlotData/./src/constants.ts?");

/***/ }),

/***/ "./src/core.ts":
/*!*********************!*\
  !*** ./src/core.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AXES_BLANK_SPACE\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.AXES_BLANK_SPACE),\n/* harmony export */   \"AXIS_TAIL_SIZE\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.AXIS_TAIL_SIZE),\n/* harmony export */   \"AbstractHalfLine\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.AbstractHalfLine),\n/* harmony export */   \"AbstractLinePoint\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.AbstractLinePoint),\n/* harmony export */   \"AbstractTriangle\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.AbstractTriangle),\n/* harmony export */   \"Arc\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.Arc),\n/* harmony export */   \"Axis\": () => (/* reexport safe */ _axes__WEBPACK_IMPORTED_MODULE_0__.Axis),\n/* harmony export */   \"Bar\": () => (/* reexport safe */ _shapes__WEBPACK_IMPORTED_MODULE_11__.Bar),\n/* harmony export */   \"CIRCLES\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.CIRCLES),\n/* harmony export */   \"CLICKED_SHAPE_COLOR\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.CLICKED_SHAPE_COLOR),\n/* harmony export */   \"CROSSES\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.CROSSES),\n/* harmony export */   \"Circle\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.Circle),\n/* harmony export */   \"Contour\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.Contour),\n/* harmony export */   \"Cross\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.Cross),\n/* harmony export */   \"DASH_SELECTION_WINDOW\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.DASH_SELECTION_WINDOW),\n/* harmony export */   \"DEFAULT_FONTSIZE\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_FONTSIZE),\n/* harmony export */   \"DEFAULT_SHAPE_COLOR\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_SHAPE_COLOR),\n/* harmony export */   \"DRAW_MARGIN_FACTOR\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.DRAW_MARGIN_FACTOR),\n/* harmony export */   \"DownHalfLine\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.DownHalfLine),\n/* harmony export */   \"DownTriangle\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.DownTriangle),\n/* harmony export */   \"Draw\": () => (/* reexport safe */ _figures__WEBPACK_IMPORTED_MODULE_5__.Draw),\n/* harmony export */   \"EMPTY_MULTIPLOT\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.EMPTY_MULTIPLOT),\n/* harmony export */   \"FIGURES_BLANK_SPACE\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.FIGURES_BLANK_SPACE),\n/* harmony export */   \"FREE_SPACE_FACTOR\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.FREE_SPACE_FACTOR),\n/* harmony export */   \"Figure\": () => (/* reexport safe */ _figures__WEBPACK_IMPORTED_MODULE_5__.Figure),\n/* harmony export */   \"Frame\": () => (/* reexport safe */ _figures__WEBPACK_IMPORTED_MODULE_5__.Frame),\n/* harmony export */   \"Graph2D\": () => (/* reexport safe */ _figures__WEBPACK_IMPORTED_MODULE_5__.Graph2D),\n/* harmony export */   \"GroupCollection\": () => (/* reexport safe */ _collections__WEBPACK_IMPORTED_MODULE_2__.GroupCollection),\n/* harmony export */   \"HALF_LINES\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.HALF_LINES),\n/* harmony export */   \"HOVERED_SHAPE_COLOR\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.HOVERED_SHAPE_COLOR),\n/* harmony export */   \"HalfLine\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.HalfLine),\n/* harmony export */   \"Hatching\": () => (/* reexport safe */ _styles__WEBPACK_IMPORTED_MODULE_12__.Hatching),\n/* harmony export */   \"Histogram\": () => (/* reexport safe */ _figures__WEBPACK_IMPORTED_MODULE_5__.Histogram),\n/* harmony export */   \"HorizontalLinePoint\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.HorizontalLinePoint),\n/* harmony export */   \"INFINITE_LINE_FACTOR\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.INFINITE_LINE_FACTOR),\n/* harmony export */   \"InteractiveObject\": () => (/* reexport safe */ _baseShape__WEBPACK_IMPORTED_MODULE_1__.InteractiveObject),\n/* harmony export */   \"LABEL_TEXT_OFFSET\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.LABEL_TEXT_OFFSET),\n/* harmony export */   \"LEGEND_MARGIN\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.LEGEND_MARGIN),\n/* harmony export */   \"Label\": () => (/* reexport safe */ _shapes__WEBPACK_IMPORTED_MODULE_11__.Label),\n/* harmony export */   \"LeftHalfLine\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.LeftHalfLine),\n/* harmony export */   \"LeftTriangle\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.LeftTriangle),\n/* harmony export */   \"Line\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.Line),\n/* harmony export */   \"LinePoint\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.LinePoint),\n/* harmony export */   \"LineSegment\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.LineSegment),\n/* harmony export */   \"LineSequence\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.LineSequence),\n/* harmony export */   \"List\": () => (/* reexport safe */ _old__WEBPACK_IMPORTED_MODULE_13__.List),\n/* harmony export */   \"MARKERS\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.MARKERS),\n/* harmony export */   \"MAX_LABEL_HEIGHT\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.MAX_LABEL_HEIGHT),\n/* harmony export */   \"MIN_OFFSET_X\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.MIN_OFFSET_X),\n/* harmony export */   \"MIN_OFFSET_Y\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.MIN_OFFSET_Y),\n/* harmony export */   \"Mark\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.Mark),\n/* harmony export */   \"Multiplot\": () => (/* reexport safe */ _multiplot__WEBPACK_IMPORTED_MODULE_8__.Multiplot),\n/* harmony export */   \"NegativeLinePoint\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.NegativeLinePoint),\n/* harmony export */   \"PG_CONTAINER_PLOT\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.PG_CONTAINER_PLOT),\n/* harmony export */   \"PICKABLE_BORDER_SIZE\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.PICKABLE_BORDER_SIZE),\n/* harmony export */   \"ParallelAxis\": () => (/* reexport safe */ _axes__WEBPACK_IMPORTED_MODULE_0__.ParallelAxis),\n/* harmony export */   \"ParallelPlot\": () => (/* reexport safe */ _figures__WEBPACK_IMPORTED_MODULE_5__.ParallelPlot),\n/* harmony export */   \"Point\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.Point),\n/* harmony export */   \"PointSet\": () => (/* reexport safe */ _collections__WEBPACK_IMPORTED_MODULE_2__.PointSet),\n/* harmony export */   \"PointStyle\": () => (/* reexport safe */ _styles__WEBPACK_IMPORTED_MODULE_12__.PointStyle),\n/* harmony export */   \"PositiveLinePoint\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.PositiveLinePoint),\n/* harmony export */   \"PrimitiveGroupContainer\": () => (/* reexport safe */ _figures__WEBPACK_IMPORTED_MODULE_5__.PrimitiveGroupContainer),\n/* harmony export */   \"REGEX_SAMPLES\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.REGEX_SAMPLES),\n/* harmony export */   \"RUBBERBAND_SMALL_SIZE\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.RUBBERBAND_SMALL_SIZE),\n/* harmony export */   \"Rect\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.Rect),\n/* harmony export */   \"RemoteFigure\": () => (/* reexport safe */ _remoteFigure__WEBPACK_IMPORTED_MODULE_10__.RemoteFigure),\n/* harmony export */   \"RightHalfLine\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.RightHalfLine),\n/* harmony export */   \"RightTriangle\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.RightTriangle),\n/* harmony export */   \"RoundRect\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.RoundRect),\n/* harmony export */   \"RubberBand\": () => (/* reexport safe */ _shapes__WEBPACK_IMPORTED_MODULE_11__.RubberBand),\n/* harmony export */   \"SELECTED_SHAPE_COLOR\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.SELECTED_SHAPE_COLOR),\n/* harmony export */   \"SIZE_AXIS_END\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.SIZE_AXIS_END),\n/* harmony export */   \"SQUARES\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.SQUARES),\n/* harmony export */   \"STROKE_STYLE_OFFSET\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.STROKE_STYLE_OFFSET),\n/* harmony export */   \"Scatter\": () => (/* reexport safe */ _figures__WEBPACK_IMPORTED_MODULE_5__.Scatter),\n/* harmony export */   \"ScatterPoint\": () => (/* reexport safe */ _shapes__WEBPACK_IMPORTED_MODULE_11__.ScatterPoint),\n/* harmony export */   \"SelectionBox\": () => (/* reexport safe */ _shapes__WEBPACK_IMPORTED_MODULE_11__.SelectionBox),\n/* harmony export */   \"SelectionBoxCollection\": () => (/* reexport safe */ _collections__WEBPACK_IMPORTED_MODULE_2__.SelectionBoxCollection),\n/* harmony export */   \"Shape\": () => (/* reexport safe */ _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape),\n/* harmony export */   \"ShapeCollection\": () => (/* reexport safe */ _collections__WEBPACK_IMPORTED_MODULE_2__.ShapeCollection),\n/* harmony export */   \"TEXT_SEPARATORS\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.TEXT_SEPARATORS),\n/* harmony export */   \"TOOLTIP_PRECISION\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.TOOLTIP_PRECISION),\n/* harmony export */   \"TOOLTIP_TEXT_OFFSET\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.TOOLTIP_TEXT_OFFSET),\n/* harmony export */   \"TOOLTIP_TRIANGLE_SIZE\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.TOOLTIP_TRIANGLE_SIZE),\n/* harmony export */   \"TRIANGLES\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.TRIANGLES),\n/* harmony export */   \"Text\": () => (/* reexport safe */ _shapes__WEBPACK_IMPORTED_MODULE_11__.Text),\n/* harmony export */   \"TitleSettings\": () => (/* reexport safe */ _axes__WEBPACK_IMPORTED_MODULE_0__.TitleSettings),\n/* harmony export */   \"Tooltip\": () => (/* reexport safe */ _shapes__WEBPACK_IMPORTED_MODULE_11__.Tooltip),\n/* harmony export */   \"Triangle\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.Triangle),\n/* harmony export */   \"UpHalfLine\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.UpHalfLine),\n/* harmony export */   \"UpTriangle\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.UpTriangle),\n/* harmony export */   \"Vertex\": () => (/* reexport safe */ _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex),\n/* harmony export */   \"VerticalLinePoint\": () => (/* reexport safe */ _primitives__WEBPACK_IMPORTED_MODULE_9__.VerticalLinePoint),\n/* harmony export */   \"ZOOM_FACTOR\": () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_4__.ZOOM_FACTOR),\n/* harmony export */   \"addInitZero\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.addInitZero),\n/* harmony export */   \"argMax\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.argMax),\n/* harmony export */   \"argMin\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.argMin),\n/* harmony export */   \"arrayDiff\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.arrayDiff),\n/* harmony export */   \"arrayHexToHsl\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.arrayHexToHsl),\n/* harmony export */   \"arrayHexToRgb\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.arrayHexToRgb),\n/* harmony export */   \"arrayHslToHex\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.arrayHslToHex),\n/* harmony export */   \"arrayHslToRgb\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.arrayHslToRgb),\n/* harmony export */   \"arrayIntersection\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.arrayIntersection),\n/* harmony export */   \"arrayRgbToHex\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.arrayRgbToHex),\n/* harmony export */   \"arrayRgbToHsl\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.arrayRgbToHsl),\n/* harmony export */   \"colorHex\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.colorHex),\n/* harmony export */   \"colorHsl\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.colorHsl),\n/* harmony export */   \"colorRgb\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.colorRgb),\n/* harmony export */   \"componentToHex\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.componentToHex),\n/* harmony export */   \"computeCanvasSize\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.computeCanvasSize),\n/* harmony export */   \"datesInDays\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.datesInDays),\n/* harmony export */   \"datesInHours\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.datesInHours),\n/* harmony export */   \"datesInMilliseconds\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.datesInMilliseconds),\n/* harmony export */   \"datesInMinutes\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.datesInMinutes),\n/* harmony export */   \"datesInSeconds\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.datesInSeconds),\n/* harmony export */   \"deserialize\": () => (/* reexport safe */ _shapeFunctions__WEBPACK_IMPORTED_MODULE_6__.deserialize),\n/* harmony export */   \"drawTooltip\": () => (/* reexport safe */ _shapeFunctions__WEBPACK_IMPORTED_MODULE_6__.drawTooltip),\n/* harmony export */   \"equals\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.equals),\n/* harmony export */   \"formatDateTicks\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.formatDateTicks),\n/* harmony export */   \"getTenPower\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.getTenPower),\n/* harmony export */   \"hexToHsl\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.hexToHsl),\n/* harmony export */   \"hexToRgb\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.hexToRgb),\n/* harmony export */   \"hslToArray\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.hslToArray),\n/* harmony export */   \"hslToHex\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.hslToHex),\n/* harmony export */   \"hslToRgb\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.hslToRgb),\n/* harmony export */   \"hslToString\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.hslToString),\n/* harmony export */   \"initializeTooltip\": () => (/* reexport safe */ _shapeFunctions__WEBPACK_IMPORTED_MODULE_6__.initializeTooltip),\n/* harmony export */   \"intersectArrays\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.intersectArrays),\n/* harmony export */   \"isInteger\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.isInteger),\n/* harmony export */   \"isIntegerArray\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.isIntegerArray),\n/* harmony export */   \"mapMax\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.mapMax),\n/* harmony export */   \"mapMin\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.mapMin),\n/* harmony export */   \"mean\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.mean),\n/* harmony export */   \"normalizeArray\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.normalizeArray),\n/* harmony export */   \"range\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.range),\n/* harmony export */   \"rgbToArray\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.rgbToArray),\n/* harmony export */   \"rgbToHex\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.rgbToHex),\n/* harmony export */   \"rgbToHsl\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.rgbToHsl),\n/* harmony export */   \"rgbToString\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.rgbToString),\n/* harmony export */   \"scaleArray\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.scaleArray),\n/* harmony export */   \"standardDeviation\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.standardDeviation),\n/* harmony export */   \"string_to_hex\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.string_to_hex),\n/* harmony export */   \"string_to_hex_dict\": () => (/* reexport safe */ _colors__WEBPACK_IMPORTED_MODULE_3__.string_to_hex_dict),\n/* harmony export */   \"styleToLegend\": () => (/* reexport safe */ _shapeFunctions__WEBPACK_IMPORTED_MODULE_6__.styleToLegend),\n/* harmony export */   \"sum\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.sum),\n/* harmony export */   \"uniqueValues\": () => (/* reexport safe */ _functions__WEBPACK_IMPORTED_MODULE_7__.uniqueValues)\n/* harmony export */ });\n/* harmony import */ var _axes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./axes */ \"./src/axes.ts\");\n/* harmony import */ var _baseShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./baseShape */ \"./src/baseShape.ts\");\n/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collections */ \"./src/collections.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _figures__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./figures */ \"./src/figures.ts\");\n/* harmony import */ var _shapeFunctions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shapeFunctions */ \"./src/shapeFunctions.ts\");\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./functions */ \"./src/functions.ts\");\n/* harmony import */ var _multiplot__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./multiplot */ \"./src/multiplot.ts\");\n/* harmony import */ var _primitives__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./primitives */ \"./src/primitives.ts\");\n/* harmony import */ var _remoteFigure__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./remoteFigure */ \"./src/remoteFigure.ts\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./shapes */ \"./src/shapes.ts\");\n/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./styles */ \"./src/styles.ts\");\n/* harmony import */ var _old__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./old */ \"./src/old.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://PlotData/./src/core.ts?");

/***/ }),

/***/ "./src/figures.ts":
/*!************************!*\
  !*** ./src/figures.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Draw\": () => (/* binding */ Draw),\n/* harmony export */   \"Figure\": () => (/* binding */ Figure),\n/* harmony export */   \"Frame\": () => (/* binding */ Frame),\n/* harmony export */   \"Graph2D\": () => (/* binding */ Graph2D),\n/* harmony export */   \"Histogram\": () => (/* binding */ Histogram),\n/* harmony export */   \"ParallelPlot\": () => (/* binding */ ParallelPlot),\n/* harmony export */   \"PrimitiveGroupContainer\": () => (/* binding */ PrimitiveGroupContainer),\n/* harmony export */   \"Scatter\": () => (/* binding */ Scatter)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions */ \"./src/functions.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./styles */ \"./src/styles.ts\");\n/* harmony import */ var _baseShape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./baseShape */ \"./src/baseShape.ts\");\n/* harmony import */ var _primitives__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./primitives */ \"./src/primitives.ts\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shapes */ \"./src/shapes.ts\");\n/* harmony import */ var _axes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./axes */ \"./src/axes.ts\");\n/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./collections */ \"./src/collections.ts\");\n/* harmony import */ var _remoteFigure__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./remoteFigure */ \"./src/remoteFigure.ts\");\n\n\n\n\n\n\n\n\n\n\nclass Figure extends _remoteFigure__WEBPACK_IMPORTED_MODULE_9__.RemoteFigure {\n    constructor(data, width, height, X, Y, canvasID, is_in_multiplot = false) {\n        super(data, width, height, X, Y, canvasID, is_in_multiplot);\n        this.width = width;\n        this.height = height;\n        this.canvasID = canvasID;\n        this.is_in_multiplot = is_in_multiplot;\n    }\n    static fromMultiplot(data, width, height, canvasID) {\n        if (data.type_ == \"histogram\")\n            return new Histogram(data, width, height, 0, 0, canvasID, true);\n        if (data.type_ == \"parallelplot\")\n            return new ParallelPlot(data, width, height, 0, 0, canvasID, true);\n        if (data.type_ == \"draw\")\n            return new Draw(data, width, height, 0, 0, canvasID, true);\n        if (data.type_ == \"graph2d\")\n            return new Graph2D(data, width, height, 0, 0, canvasID, true);\n        if (data.type_ == \"primitivegroupcontainer\")\n            return new PrimitiveGroupContainer(data, width, height, false, 0, 0, canvasID, true);\n        if (data.type_ == \"scatterplot\")\n            return new Scatter(data, width, height, 0, 0, canvasID, true);\n        throw Error(`${data.type_} is not a known type of plot. Possible plots <type_> attributes are 'scatterplot', 'graph2d', 'parallelplot', 'histogram', 'draw', 'primitivegroupcontainer'.`);\n    }\n    static createFromMultiplot(data, features, context, canvasID) {\n        const plot = Figure.fromMultiplot(data, 500, 500, canvasID);\n        plot.features = features;\n        plot.context = context;\n        return plot;\n    }\n    multiplotDraw(origin, width, height) {\n        this.changeLocationInCanvas(origin, width, height);\n        this.resetView();\n    }\n    sendHoveredIndicesMultiplot() { return this.hoveredIndices; }\n    receiveMultiplotMouseIndices(multiplotHovered, multiplotClicked, multiplotSelected) {\n        this.selectedIndices = multiplotSelected;\n        this.clickedIndices = [...multiplotClicked];\n        this.hoveredIndices = [...multiplotHovered];\n    }\n    multiplotSelectedIntersection(multiplotSelected, isSelecting) {\n        this.axes.forEach(axis => {\n            if (axis.rubberBand.length != 0 && axis.name != \"number\") {\n                isSelecting = true;\n                const selectedIndices = this.updateSelected(axis);\n                multiplotSelected = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.arrayIntersection)(multiplotSelected, selectedIndices);\n            }\n        });\n        return [multiplotSelected, isSelecting];\n    }\n    receivePointSets(pointSets) { this.pointSets = pointSets; }\n    initRubberBandMultiplot(multiplotRubberBands) {\n        this.axes.forEach(axis => axis.sendRubberBand(multiplotRubberBands));\n    }\n    updateRubberBandMultiplot(multiplotRubberBands) {\n        this.axes.forEach(axis => axis.sendRubberBandRange(multiplotRubberBands));\n    }\n    sendRubberBandsMultiplot(figures) {\n        figures.forEach(figure => figure.receiveRubberBandFromFigure(this));\n    }\n    sendRubberBandsInFigure(figure) {\n        figure.axes.forEach(otherAxis => {\n            this.axes.forEach(thisAxis => {\n                if (thisAxis.name == otherAxis.name && thisAxis.name != \"number\") {\n                    otherAxis.rubberBand.minValue = thisAxis.rubberBand.minValue;\n                    otherAxis.rubberBand.maxValue = thisAxis.rubberBand.maxValue;\n                    otherAxis.emitter.emit(\"rubberBandChange\", otherAxis.rubberBand);\n                }\n            });\n        });\n    }\n    receiveRubberBandFromFigure(figure) { figure.sendRubberBandsInFigure(this); }\n}\nclass Frame extends Figure {\n    constructor(data, width, height, X, Y, canvasID, is_in_multiplot = false) {\n        super(data, width, height, X, Y, canvasID, is_in_multiplot);\n        this.width = width;\n        this.height = height;\n        this.canvasID = canvasID;\n        this.is_in_multiplot = is_in_multiplot;\n        this.setAxesTitleWidth();\n    }\n    get frameMatrix() {\n        const relativeMatrix = this.axes[0].transformMatrix;\n        relativeMatrix.d = this.axes[1].transformMatrix.a;\n        relativeMatrix.f = this.axes[1].transformMatrix.f;\n        return relativeMatrix;\n    }\n    get relativeMatrix() { return this.canvasMatrix.multiply(this.frameMatrix); }\n    get nXTicks() { var _a; return (_a = this._nXTicks) !== null && _a !== void 0 ? _a : 10; }\n    set nXTicks(value) { this._nXTicks = value; }\n    get nYTicks() { var _a; return (_a = this._nYTicks) !== null && _a !== void 0 ? _a : 10; }\n    set nYTicks(value) { this._nYTicks = value; }\n    get sampleDrawings() { return this.relativeObjects; }\n    get drawingZone() {\n        const origin = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex();\n        origin.x = this.initScale.x < 0 ? this.axes[0].end.x : this.axes[0].origin.x;\n        origin.y = this.initScale.y < 0 ? this.axes[1].end.y : this.axes[1].origin.y;\n        const size = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(Math.abs(this.axes[0].end.x - this.axes[0].origin.x), Math.abs(this.axes[1].end.y - this.axes[1].origin.y));\n        return [origin.transform(this.canvasMatrix.inverse()), size];\n    }\n    get axesEnd() { return new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.axes[0].end.x, this.axes[1].end.y).transform(this.canvasMatrix); }\n    setAxesTitleWidth() {\n        this.axes.forEach(axis => axis.titleWidth = this.drawingZone[1].x - 5);\n    }\n    unpackAxisStyle(data) {\n        var _a, _b, _c, _d;\n        super.unpackAxisStyle(data);\n        this.nXTicks = (_b = (_a = data.axis) === null || _a === void 0 ? void 0 : _a.nb_points_x) !== null && _b !== void 0 ? _b : this.nXTicks;\n        this.nYTicks = (_d = (_c = data.axis) === null || _c === void 0 ? void 0 : _c.nb_points_y) !== null && _d !== void 0 ? _d : this.nYTicks;\n    }\n    mouseMove(canvasMouse, absoluteMouse, frameMouse) {\n        super.mouseMove(canvasMouse, absoluteMouse, frameMouse);\n        this.hoveredIndices = this.sampleDrawings.updateShapeStates('isHovered');\n    }\n    mouseUp(ctrlKey) {\n        super.mouseUp(ctrlKey);\n        this.clickedIndices = this.sampleDrawings.updateShapeStates('isClicked');\n    }\n    setFeatures(data) {\n        [this.xFeature, this.yFeature] = super.setFeatures(data);\n        if (!this.xFeature) {\n            this.xFeature = \"indices\";\n            this.features.set(\"indices\", Array.from(Array(this.nSamples).keys()));\n        }\n        if (!this.yFeature) {\n            for (let key of Array.from(this.features.keys())) {\n                if (![\"name\", \"indices\"].includes(key)) {\n                    this.yFeature = key;\n                    break;\n                }\n            }\n        }\n        return [this.xFeature, this.yFeature];\n    }\n    changeAxisFeature(name, index) {\n        if (index == 0)\n            this.xFeature = name;\n        else\n            this.yFeature = name;\n        super.changeAxisFeature(name, index);\n    }\n    transformAxes(axisBoundingBoxes) {\n        super.transformAxes(axisBoundingBoxes);\n        this.axes[0].transform(this.drawOrigin, new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawEnd.x, this.drawOrigin.y));\n        this.axes[1].transform(this.drawOrigin, new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawOrigin.x, this.drawEnd.y));\n    }\n    buildAxes(axisBoundingBoxes) {\n        super.buildAxes(axisBoundingBoxes);\n        return [\n            this.setAxis(this.xFeature, axisBoundingBoxes[0], this.drawOrigin, new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawEnd.x, this.drawOrigin.y), this.nXTicks),\n            this.setAxis(this.yFeature, axisBoundingBoxes[1], this.drawOrigin, new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawOrigin.x, this.drawEnd.y), this.nYTicks)\n        ];\n    }\n    buildAxisBoundingBoxes(freeSpace) {\n        const xBoundingBox = new _primitives__WEBPACK_IMPORTED_MODULE_5__.Rect(new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawOrigin.x, this.drawOrigin.y - freeSpace.y), new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawEnd.x - this.drawOrigin.x, freeSpace.y));\n        const yBoundingBox = new _primitives__WEBPACK_IMPORTED_MODULE_5__.Rect(new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawOrigin.x - freeSpace.x, this.drawOrigin.y), new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(freeSpace.x - _constants__WEBPACK_IMPORTED_MODULE_0__.AXES_BLANK_SPACE, this.drawEnd.y - this.drawOrigin.y));\n        return [xBoundingBox, yBoundingBox];\n    }\n    drawRelativeObjects(context) {\n        super.drawRelativeObjects(context);\n        if (this.isRubberBanded())\n            this.updateSelectionBox(...this.rubberBandsCorners);\n    }\n    updateSelectionBox(frameDown, frameMouse) {\n        this.axes[0].rubberBand.minValue = Math.min(frameDown.x, frameMouse.x);\n        this.axes[1].rubberBand.minValue = Math.min(frameDown.y, frameMouse.y);\n        this.axes[0].rubberBand.maxValue = Math.max(frameDown.x, frameMouse.x);\n        this.axes[1].rubberBand.maxValue = Math.max(frameDown.y, frameMouse.y);\n        super.updateSelectionBox(...this.rubberBandsCorners);\n    }\n    switchZoom() { this.isZooming = !this.isZooming; }\n    updateZoomBox(frameDown, frameMouse) {\n        if (this.isZooming)\n            this.zoomBox.update(frameDown, frameMouse);\n    }\n    get rubberBandsCorners() {\n        return [new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.axes[0].rubberBand.minValue, this.axes[1].rubberBand.minValue), new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.axes[0].rubberBand.maxValue, this.axes[1].rubberBand.maxValue)];\n    }\n    activateSelection(emittedRubberBand, index) {\n        super.activateSelection(emittedRubberBand, index);\n        this.selectionBox.rubberBandUpdate(emittedRubberBand, [\"x\", \"y\"][index]);\n    }\n}\nclass Histogram extends Frame {\n    constructor(data, width, height, X, Y, canvasID, is_in_multiplot = false) {\n        super(data, width, height, X, Y, canvasID, is_in_multiplot);\n        this.width = width;\n        this.height = height;\n        this.canvasID = canvasID;\n        this.is_in_multiplot = is_in_multiplot;\n        this.bars = [];\n        this.fillStyle = _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SHAPE_COLOR;\n        this.strokeStyle = null;\n        this.dashLine = [];\n        this.unpackBarStyle(data);\n    }\n    get nXTicks() { return this._nXTicks ? this._nXTicks : 20; }\n    set nXTicks(value) { this._nXTicks = value; }\n    get nYTicks() { return this._nYTicks ? this._nYTicks : 10; }\n    set nYTicks(value) { this._nYTicks = value; }\n    unpackAxisStyle(data) {\n        super.unpackAxisStyle(data);\n        if (data.graduation_nb)\n            this.nXTicks = data.graduation_nb;\n    }\n    unpackBarStyle(data) {\n        var _a, _b, _c, _d;\n        if ((_a = data.surface_style) === null || _a === void 0 ? void 0 : _a.color_fill)\n            this.fillStyle = data.surface_style.color_fill;\n        if ((_b = data.edge_style) === null || _b === void 0 ? void 0 : _b.line_width)\n            this.lineWidth = data.edge_style.line_width;\n        if ((_c = data.edge_style) === null || _c === void 0 ? void 0 : _c.color_stroke)\n            this.strokeStyle = data.edge_style.color_stroke;\n        if ((_d = data.edge_style) === null || _d === void 0 ? void 0 : _d.dashline)\n            this.dashLine = data.edge_style.dashline;\n    }\n    reset() {\n        super.reset();\n        this.bars = [];\n        this.draw();\n    }\n    updateNumberAxis(numberAxis, bars) {\n        this.features.set('number', this.getNumberFeature(bars));\n        numberAxis.minValue = 0;\n        numberAxis.maxValue = Math.max(...this.features.get(this.yFeature)) + 1;\n        numberAxis.saveLocation();\n        numberAxis.updateTicks();\n        return numberAxis;\n    }\n    getNumberFeature(bars) {\n        const numberFeature = this.features.get(this.xFeature).map(() => 0);\n        bars.forEach(bar => bar.values.forEach(value => numberFeature[value] = bar.length));\n        return numberFeature;\n    }\n    boundedTicks(axis) {\n        let fakeTicks = [axis.minValue].concat(axis.ticks);\n        fakeTicks.push(axis.maxValue);\n        return fakeTicks;\n    }\n    fakeFeatures() {\n        if (!this.features.has(this.xFeature))\n            this.features.set(this.xFeature, []);\n    }\n    computeBars(vector) {\n        var _a;\n        this.fakeFeatures();\n        const baseAxis = (_a = this.axes[0]) !== null && _a !== void 0 ? _a : this.setAxis(this.xFeature, new _primitives__WEBPACK_IMPORTED_MODULE_5__.Rect(), new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(), new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(), this.nXTicks);\n        const numericVector = baseAxis.stringsToValues(vector !== null && vector !== void 0 ? vector : []);\n        let fakeTicks = this.boundedTicks(baseAxis);\n        let bars = Array.from(Array(fakeTicks.length - 1), () => new _shapes__WEBPACK_IMPORTED_MODULE_6__.Bar([]));\n        let barValues = Array.from(Array(fakeTicks.length - 1), () => []);\n        numericVector.forEach((value, valIdx) => {\n            for (let tickIdx = 0; tickIdx < fakeTicks.length - 1; tickIdx++) {\n                if (value >= fakeTicks[tickIdx] && value < fakeTicks[tickIdx + 1]) {\n                    bars[tickIdx].values.push(valIdx);\n                    barValues[tickIdx].push(value);\n                    break;\n                }\n            }\n        });\n        barValues.forEach((values, index) => bars[index].computeStats(values));\n        return bars;\n    }\n    computeRelativeObjects() {\n        super.computeRelativeObjects();\n        this.bars = this.computeBars(this.features.get(this.xFeature));\n        this.axes[1] = this.updateNumberAxis(this.axes[1], this.bars);\n        this.getBarsDrawing();\n    }\n    drawRelativeObjects(context) {\n        super.drawRelativeObjects(context);\n        this.bars.forEach(bar => bar.draw(this.context));\n        this.relativeObjects.shapes = [...this.bars, ...this.relativeObjects.shapes];\n    }\n    getBarSetColor(bar) {\n        const setMaps = new Map();\n        bar.values.forEach(pointIndex => {\n            this.pointSets.forEach((pointSet, index) => {\n                if (pointSet.includes(pointIndex))\n                    setMaps.set(index, setMaps.get(index) ? setMaps.get(index) + 1 : 1);\n            });\n        });\n        const pointsSetIndex = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.mapMax)(setMaps)[0];\n        if (pointsSetIndex !== null)\n            return (0,_colors__WEBPACK_IMPORTED_MODULE_2__.colorHsl)(this.pointSets[pointsSetIndex].color);\n    }\n    getBarsDrawing() {\n        const fullTicks = this.boundedTicks(this.axes[0]);\n        const minY = this.boundedTicks(this.axes[1])[0];\n        this.bars.forEach((bar, index) => {\n            var _a;\n            let origin = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(fullTicks[index], minY);\n            let size = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(fullTicks[index + 1] - fullTicks[index], bar.length > minY ? bar.length - minY : 0);\n            if (this.axes[0].isDiscrete)\n                origin.x = origin.x - (fullTicks[2] - fullTicks[1]) / 2;\n            const color = (_a = this.getBarSetColor(bar)) !== null && _a !== void 0 ? _a : this.fillStyle;\n            bar.updateStyle(origin, size, this.hoveredIndices, this.clickedIndices, this.selectedIndices, color, this.strokeStyle, this.dashLine, this.lineWidth);\n        });\n    }\n    buildAxes(axisBoundingBoxes) {\n        const bars = this.computeBars(this.features.get(this.xFeature));\n        this.features.set('number', this.getNumberFeature(bars));\n        const [xAxis, yAxis] = super.buildAxes(axisBoundingBoxes);\n        return [xAxis, this.updateNumberAxis(yAxis, bars)];\n    }\n    setFeatures(data) {\n        data[\"attribute_names\"] = [data.x_variable, 'number']; // legacy, will disappear\n        return super.setFeatures(data);\n    }\n    mouseTranslate(currentMouse, mouseDown) {\n        const translation = super.mouseTranslate(currentMouse, mouseDown);\n        return new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.axes[0].isDiscrete ? 0 : translation.x, 0);\n    }\n    regulateAxisScale(axis) {\n        if (!axis.isDate) {\n            if (axis.tickPrecision >= this.MAX_PRINTED_NUMBERS) {\n                if (this.scaleX > 1)\n                    this.scaleX = 1;\n            }\n            else if (axis.tickPrecision < 1 || axis.areAllLabelsDisplayed) {\n                if (this.scaleX < 1)\n                    this.scaleX = 1;\n            }\n        }\n    }\n    regulateScale() {\n        this.scaleY = 1;\n        super.regulateScale();\n    }\n    initRubberBandMultiplot(multiplotRubberBands) {\n        this.axes[0].sendRubberBand(multiplotRubberBands);\n    }\n    updateRubberBandMultiplot(multiplotRubberBands) {\n        this.axes[0].sendRubberBandRange(multiplotRubberBands);\n    }\n    sendRubberBandsInFigure(figure) {\n        figure.axes.forEach(otherAxis => {\n            if (this.axes[0].name == otherAxis.name) {\n                otherAxis.rubberBand.minValue = this.axes[0].rubberBand.minValue;\n                otherAxis.rubberBand.maxValue = this.axes[0].rubberBand.maxValue;\n                otherAxis.emitter.emit(\"rubberBandChange\", otherAxis.rubberBand);\n            }\n        });\n    }\n}\nclass Scatter extends Frame {\n    constructor(data, width, height, X, Y, canvasID, is_in_multiplot = false) {\n        super(data, width, height, X, Y, canvasID, is_in_multiplot);\n        this.width = width;\n        this.height = height;\n        this.canvasID = canvasID;\n        this.is_in_multiplot = is_in_multiplot;\n        this.points = [];\n        this.fillStyle = _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SHAPE_COLOR;\n        this.strokeStyle = null;\n        this.marker = 'circle';\n        this.pointSize = 8;\n        this.isMerged = false;\n        if (this.nSamples > 0) {\n            this.tooltipAttributes = data.tooltip ? data.tooltip.attribute : Array.from(this.features.keys());\n            this.unpackPointStyle(data);\n            this.computePoints();\n        }\n    }\n    get sampleDrawings() { return this.absoluteObjects; }\n    unpackPointStyle(data) {\n        var _a, _b, _c, _d, _e;\n        if ((_a = data.point_style) === null || _a === void 0 ? void 0 : _a.color_fill)\n            this.fillStyle = data.point_style.color_fill;\n        if ((_b = data.point_style) === null || _b === void 0 ? void 0 : _b.color_stroke)\n            this.strokeStyle = data.point_style.color_stroke;\n        if ((_c = data.point_style) === null || _c === void 0 ? void 0 : _c.shape)\n            this.marker = data.point_style.shape;\n        if ((_d = data.point_style) === null || _d === void 0 ? void 0 : _d.stroke_width)\n            this.lineWidth = data.point_style.stroke_width;\n        if ((_e = data.point_style) === null || _e === void 0 ? void 0 : _e.size)\n            this.pointSize = data.point_style.size;\n        if (data.tooltip)\n            this.tooltipAttributes = data.tooltip.attributes;\n    }\n    resetScales() {\n        super.resetScales();\n        this.computePoints();\n    }\n    boundingBoxResize(origin, width, height) {\n        super.boundingBoxResize(origin, width, height);\n        this.computePoints();\n    }\n    reset() {\n        super.reset();\n        this.computePoints();\n        this.resetClusters();\n    }\n    resize() {\n        super.resize();\n        this.computePoints();\n    }\n    drawAbsoluteObjects(context) {\n        super.drawAbsoluteObjects(context);\n        this.drawPoints(context);\n        this.absoluteObjects.shapes = [...this.points, ...this.absoluteObjects.shapes];\n    }\n    ;\n    drawPoints(context) {\n        const axesOrigin = this.axes[0].origin;\n        const axesEnd = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.axes[0].end.x, this.axes[1].end.y);\n        this.points.forEach(point => this.drawPoint(point, axesOrigin, axesEnd, context));\n    }\n    drawPoint(point, axesOrigin, axesEnd, context) {\n        var _a;\n        const colors = point.updateDrawingState(this.clusterColors, this.hoveredIndices, this.clickedIndices, this.selectedIndices);\n        const color = colors.size != 0 ? (0,_functions__WEBPACK_IMPORTED_MODULE_1__.mapMax)(colors)[0] : ((_a = this.getPointSetColor(point)) !== null && _a !== void 0 ? _a : this.fillStyle);\n        point.updateDrawProperties(this.pointStyles, this.clusterColors, color, this.lineWidth, this.marker);\n        if (point.isInFrame(axesOrigin, axesEnd, this.initScale))\n            point.draw(context);\n    }\n    getPointSetColor(point) {\n        const setMaps = new Map();\n        point.values.forEach(pointIndex => {\n            this.pointSets.forEach((pointSet, index) => {\n                if (pointSet.includes(pointIndex))\n                    setMaps.set(index, setMaps.get(index) ? setMaps.get(index) + 1 : 1);\n            });\n        });\n        const pointsSetIndex = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.mapMax)(setMaps)[0]; // TODO: there is a refactor to do here\n        if (pointsSetIndex !== null)\n            return (0,_colors__WEBPACK_IMPORTED_MODULE_2__.colorHsl)(this.pointSets[pointsSetIndex].color);\n        return null;\n    }\n    switchMerge() {\n        this.isMerged = !this.isMerged;\n        this.computePoints();\n        this.draw();\n    }\n    zoomBoxUpdateAxes(zoomBox) {\n        super.zoomBoxUpdateAxes(zoomBox);\n        this.computePoints();\n    }\n    computePoints() {\n        const thresholdDist = 30;\n        const [xCoords, yCoords, xValues, yValues] = this.projectPoints();\n        const pointsData = { \"xCoords\": xCoords, \"yCoords\": yCoords, \"xValues\": xValues, \"yValues\": yValues };\n        const mergedPoints = this.mergePoints(xCoords, yCoords, thresholdDist);\n        this.points = mergedPoints.map(mergedIndices => {\n            return _shapes__WEBPACK_IMPORTED_MODULE_6__.ScatterPoint.fromPlottedValues(mergedIndices, pointsData, this.pointSize, this.marker, thresholdDist, this.tooltipAttributes, this.features, this.axes, this.xFeature, this.yFeature);\n        });\n    }\n    mergePoints(xCoords, yCoords, minDistance = 15) {\n        if (!this.isMerged)\n            return [...Array(xCoords.length).keys()].map(x => [x]);\n        const squareDistances = this.distanceMatrix(xCoords, yCoords);\n        const threshold = minDistance ** 2;\n        const mergedPoints = [];\n        const pointsGroups = new Array(squareDistances.length).fill([]);\n        const closedPoints = new Array(squareDistances.length).fill(0);\n        const pickedPoints = new Array(squareDistances.length).fill(false);\n        squareDistances.forEach((squareDistance, pointIndex) => {\n            const pointGroup = [];\n            let nPoints = 0;\n            squareDistance.forEach((distance, otherIndex) => {\n                if (distance <= threshold) {\n                    nPoints++;\n                    pointGroup.push(otherIndex);\n                }\n            });\n            closedPoints[pointIndex] = nPoints;\n            pointsGroups[pointIndex] = pointGroup;\n        });\n        while ((0,_functions__WEBPACK_IMPORTED_MODULE_1__.sum)(closedPoints) != 0) {\n            const centerIndex = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.argMax)(closedPoints)[1];\n            const cluster = [];\n            closedPoints[centerIndex] = 0;\n            pointsGroups[centerIndex].forEach(index => {\n                if (!pickedPoints[index]) {\n                    cluster.push(index);\n                    pickedPoints[index] = true;\n                }\n                closedPoints[index] = 0;\n            });\n            mergedPoints.push(cluster);\n        }\n        return mergedPoints;\n    }\n    fakeFeatures() {\n        if (!this.features.has(this.xFeature))\n            this.features.set(this.xFeature, []);\n        if (!this.features.has(this.yFeature))\n            this.features.set(this.yFeature, []);\n    }\n    projectPoints() {\n        this.fakeFeatures();\n        const xValues = this.axes[0].stringsToValues(this.features.get(this.xFeature));\n        const yValues = this.axes[1].stringsToValues(this.features.get(this.yFeature));\n        const xCoords = [];\n        const yCoords = [];\n        for (let index = 0; index < xValues.length; index++) {\n            const [xCoord, yCoord] = this.projectPoint(xValues[index], yValues[index]);\n            xCoords.push(xCoord);\n            yCoords.push(yCoord);\n        }\n        return [xCoords, yCoords, xValues, yValues];\n    }\n    projectPoint(xCoord, yCoord) {\n        return [\n            this.axes[0].relativeToAbsolute(xCoord) * this.canvasMatrix.a + this.canvasMatrix.e,\n            this.axes[1].relativeToAbsolute(yCoord) * this.canvasMatrix.d + this.canvasMatrix.f\n        ];\n    }\n    distanceMatrix(xCoords, yCoords) {\n        let squareDistances = new Array(xCoords.length);\n        for (let i = 0; i < xCoords.length; i++) {\n            if (!squareDistances[i])\n                squareDistances[i] = new Array(xCoords.length);\n            for (let j = i; j < xCoords.length; j++) {\n                squareDistances[i][j] = (xCoords[i] - xCoords[j]) ** 2 + (yCoords[i] - yCoords[j]) ** 2;\n                if (!squareDistances[j])\n                    squareDistances[j] = new Array(xCoords.length);\n                squareDistances[j][i] = squareDistances[i][j];\n            }\n        }\n        return squareDistances;\n    }\n    agglomerativeClustering(xValues, yValues, minDistance = 0.25) {\n        const squareDistances = this.distanceMatrix(xValues, yValues);\n        const threshold = minDistance ** 2;\n        let pointsGroups = [];\n        squareDistances.forEach(distances => {\n            let pointsGroup = [];\n            distances.forEach((distance, col) => { if (distance <= threshold)\n                pointsGroup.push(col); });\n            pointsGroups.push(pointsGroup);\n        });\n        let clusters = [];\n        let nClusters = -1;\n        let maxIter = 0;\n        while (nClusters != clusters.length && maxIter < 100) {\n            nClusters = clusters.length;\n            clusters = [pointsGroups[0]];\n            pointsGroups.slice(1).forEach(candidate => {\n                let isCluster = true;\n                clusters.forEach((cluster, clusterIndex) => {\n                    for (let i = 0; i < candidate.length; i++) {\n                        if (cluster.includes(candidate[i])) {\n                            candidate.forEach(point => { if (!clusters[clusterIndex].includes(point))\n                                clusters[clusterIndex].push(point); });\n                            isCluster = false;\n                            break;\n                        }\n                    }\n                });\n                if (isCluster)\n                    clusters.push(candidate);\n            });\n            pointsGroups = new Array(...clusters);\n            maxIter++;\n        }\n        return clusters;\n    }\n    simpleCluster(inputValue) {\n        this.computeClusterColors(inputValue);\n        this.draw();\n    }\n    resetClusters() {\n        this.clusterColors = null;\n        this.points.forEach(point => point.setColors(_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SHAPE_COLOR));\n        this.draw();\n    }\n    computeClusterColors(normedDistance = 0.33) {\n        const xValues = [...this.axes[0].stringsToValues(this.features.get(this.xFeature))];\n        const yValues = [...this.axes[1].stringsToValues(this.features.get(this.yFeature))];\n        const scaledX = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.normalizeArray)(xValues);\n        const scaledY = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.normalizeArray)(yValues);\n        const clusters = this.agglomerativeClustering(scaledX, scaledY, normedDistance);\n        const colorRatio = 360 / clusters.length;\n        this.clusterColors = new Array(xValues.length);\n        let colorRadius = 0;\n        clusters.forEach(cluster => {\n            colorRadius += colorRatio;\n            cluster.forEach(point => this.clusterColors[point] = `hsl(${colorRadius}, 50%, 50%, 90%)`);\n        });\n    }\n    translate(canvas, translation) {\n        super.translate(canvas, translation);\n        const pointTRL = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(translation.x * this.initScale.x, translation.y * this.initScale.y);\n        this.points.forEach((point, index) => {\n            point.center = this.previousCoords[index].add(pointTRL);\n            point.update();\n        });\n    }\n    mouseDown(canvasMouse, frameMouse, absoluteMouse) {\n        let [superCanvasMouse, superFrameMouse, clickedObject] = super.mouseDown(canvasMouse, frameMouse, absoluteMouse);\n        this.previousCoords = this.points.map(p => p.center);\n        return [superCanvasMouse, superFrameMouse, clickedObject];\n    }\n    mouseUp(ctrlKey) {\n        super.mouseUp(ctrlKey);\n        this.previousCoords = [];\n    }\n    updateWithScale() {\n        super.updateWithScale();\n        if (this.nSamples > 0)\n            this.computePoints();\n    }\n}\nclass Graph2D extends Scatter {\n    constructor(data, width, height, X, Y, canvasID, is_in_multiplot = false) {\n        super(data, width, height, X, Y, canvasID, is_in_multiplot);\n        this.width = width;\n        this.height = height;\n        this.canvasID = canvasID;\n        this.is_in_multiplot = is_in_multiplot;\n        this.showPoints = false;\n    }\n    unpackData(data) {\n        const graphSamples = [];\n        this.pointStyles = [];\n        this.curvesIndices = [];\n        this.curves = [];\n        if (data.graphs) {\n            data.graphs.forEach(graph => {\n                if (graph.elements.length != 0) {\n                    this.curves.push(_primitives__WEBPACK_IMPORTED_MODULE_5__.LineSequence.unpackGraphProperties(graph));\n                    const curveIndices = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.range)(graphSamples.length, graphSamples.length + graph.elements.length);\n                    const graphPointStyle = new _styles__WEBPACK_IMPORTED_MODULE_3__.PointStyle(graph.point_style);\n                    this.pointStyles.push(...new Array(curveIndices.length).fill(graphPointStyle));\n                    this.curvesIndices.push(curveIndices);\n                    graphSamples.push(...graph.elements);\n                }\n            });\n        }\n        return Figure.deserializeData({ \"elements\": graphSamples });\n    }\n    updateSelection(axesSelections) {\n        const inMultiplot = this.is_in_multiplot;\n        this.is_in_multiplot = false;\n        super.updateSelection(axesSelections);\n        this.is_in_multiplot = inMultiplot;\n    }\n    updateVisibleObjects(context) {\n        this.curves.forEach((curve, curveIndex) => {\n            curve.update(this.curvesIndices[curveIndex].map(index => { return this.points[index]; }));\n            curve.draw(context);\n        });\n    }\n    buildPointSets(data) { this.pointSets = []; }\n    get cuttingZone() {\n        const axesOrigin = this.axes[0].origin.transform(this.canvasMatrix);\n        const axesEnd = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.axes[0].end.x, this.axes[1].end.y).transform(this.canvasMatrix);\n        return new _primitives__WEBPACK_IMPORTED_MODULE_5__.Rect(axesOrigin, axesEnd.subtract(axesOrigin));\n    }\n    drawAbsoluteObjects(context) {\n        this.drawInZone(context);\n        if (this.showPoints) {\n            super.drawAbsoluteObjects(context);\n            this.absoluteObjects.shapes = [...this.absoluteObjects.shapes, ...this.curves];\n        }\n        else {\n            this.absoluteObjects = new _collections__WEBPACK_IMPORTED_MODULE_8__.GroupCollection([...this.curves]);\n        }\n    }\n    resetScales() {\n        const scale = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.frameMatrix.a, this.frameMatrix.d).scale(this.initScale);\n        const translation = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.axes[0].maxValue - this.axes[0].initMaxValue, this.axes[1].maxValue - this.axes[1].initMaxValue).scale(scale);\n        this.curves.forEach(curve => {\n            if (curve.mouseClick) {\n                curve.previousMouseClick = curve.previousMouseClick.add(translation);\n                curve.mouseClick = curve.previousMouseClick.copy();\n            }\n        });\n        super.resetScales();\n    }\n    switchMerge() { this.isMerged = false; }\n    togglePoints() {\n        this.showPoints = !this.showPoints;\n        this.draw();\n    }\n    translate(canvas, translation) {\n        super.translate(canvas, translation);\n        this.curves.forEach(curve => { if (curve.mouseClick)\n            curve.mouseClick = curve.previousMouseClick.add(translation.scale(this.initScale)); });\n    }\n    mouseUp(ctrlKey) {\n        super.mouseUp(ctrlKey);\n        this.curves.forEach(curve => { if (curve.mouseClick)\n            curve.previousMouseClick = curve.mouseClick.copy(); });\n    }\n    //TODO: Code duplicate, there is a middle class here between Scatter, Frame, Draw and Graph2D. Not so obvious.\n    sendHoveredIndicesMultiplot() { return []; }\n    receiveMultiplotMouseIndices(multiplotHovered, multiplotClicked, multiplotSelected) { }\n    multiplotSelectedIntersection(multiplotSelected, isSelecting) { return [multiplotSelected, isSelecting]; }\n    receivePointSets(pointSets) { }\n    initRubberBandMultiplot(multiplotRubberBands) { }\n    updateRubberBandMultiplot(multiplotRubberBands) { }\n    sendRubberBandsMultiplot(figures) { }\n    receiveRubberBandFromFigure(figure) { }\n}\nclass ParallelPlot extends Figure {\n    constructor(data, width, height, X, Y, canvasID, is_in_multiplot = false) {\n        super(data, width, height, X, Y, canvasID, is_in_multiplot);\n        this.width = width;\n        this.height = height;\n        this.canvasID = canvasID;\n        this.is_in_multiplot = is_in_multiplot;\n        this.curveColor = _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SHAPE_COLOR;\n        this.changedAxes = [];\n        this.computeCurves();\n    }\n    get isVertical() { var _a; return (_a = this._isVertical) !== null && _a !== void 0 ? _a : true; }\n    set isVertical(value) { this._isVertical = value; }\n    get offsetFactor() { var _a; return (_a = this._offsetFactor) !== null && _a !== void 0 ? _a : new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(0.005, 0.015); }\n    set offsetFactor(value) { this._offsetFactor = value; }\n    get marginFactor() { var _a; return (_a = this._marginFactor) !== null && _a !== void 0 ? _a : new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(0.005, 0.0025); }\n    set marginFactor(value) { this._marginFactor = value; }\n    shiftOnAction(canvas) { }\n    computeOffset() { return this.computeNaturalOffset(); }\n    get marginOffset() { return new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(_constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END, _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END); }\n    updateDimensions() {\n        super.updateDimensions();\n        this.updateAxesLocation();\n    }\n    switchOrientation() {\n        this.isVertical = !this.isVertical;\n        this.updateAxesLocation();\n        this.draw();\n    }\n    updateAxesLocation() {\n        const freeSpace = this.setBounds();\n        const axisBoundingBoxes = this.buildAxisBoundingBoxes(freeSpace);\n        const axesEnds = this.getAxesLocations();\n        this.axes.forEach((axis, index) => {\n            axis.updateLocation(...axesEnds[index], axisBoundingBoxes[index], index, this.drawnFeatures.length);\n        });\n        this.computeCurves();\n    }\n    buildAxes(axisBoundingBoxes) {\n        super.buildAxes(axisBoundingBoxes);\n        const axesEnds = this.getAxesLocations();\n        const axes = [];\n        this.drawnFeatures.forEach((featureName, index) => {\n            const axis = new _axes__WEBPACK_IMPORTED_MODULE_7__.ParallelAxis(this.features.get(featureName), axisBoundingBoxes[index], ...axesEnds[index], featureName, this.initScale);\n            axis.updateStyle(this.axisStyle);\n            axis.computeTitle(index, this.drawnFeatures.length);\n            axes.push(axis);\n        });\n        return axes;\n    }\n    computeBoxesSize() {\n        if (this.isVertical)\n            return (this.drawEnd.x - this.drawOrigin.x) / this.drawnFeatures.length;\n        return (this.drawEnd.y - this.drawOrigin.y) / this.drawnFeatures.length;\n    }\n    buildAxisBoundingBoxes(freeSpace) {\n        const size = this.computeBoxesSize();\n        const boundingBoxes = [];\n        this.drawnFeatures.forEach((_, index) => {\n            if (this.isVertical)\n                boundingBoxes.push(this.verticalAxisBoundingBox(this.drawOrigin, this.drawEnd.y - this.drawOrigin.y, size, index));\n            else\n                boundingBoxes.push(this.horizontalAxisBoundingBox(this.drawOrigin, this.drawEnd.x - this.drawOrigin.x, size, index));\n        });\n        return boundingBoxes;\n    }\n    horizontalAxisBoundingBox(drawOrigin, axisSize, size, index) {\n        const boundingBox = new _primitives__WEBPACK_IMPORTED_MODULE_5__.Rect(drawOrigin.copy(), new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(axisSize, size * _constants__WEBPACK_IMPORTED_MODULE_0__.FREE_SPACE_FACTOR));\n        boundingBox.origin.y += (this.drawnFeatures.length - 1 - index) * size;\n        return boundingBox;\n    }\n    verticalAxisBoundingBox(drawOrigin, axisSize, size, index) {\n        const freeSpaceOffset = size * (1 - _constants__WEBPACK_IMPORTED_MODULE_0__.FREE_SPACE_FACTOR) / 2;\n        const boundingBox = new _primitives__WEBPACK_IMPORTED_MODULE_5__.Rect(new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(drawOrigin.x + freeSpaceOffset, drawOrigin.y), new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(size - freeSpaceOffset, axisSize));\n        boundingBox.origin.x += size * index;\n        return boundingBox;\n    }\n    getAxesLocations() {\n        return this.isVertical ? this.verticalAxesLocation() : this.horizontalAxesLocation();\n    }\n    verticalAxesLocation() {\n        const boxSize = (this.drawEnd.x - this.drawOrigin.x) / this.drawnFeatures.length;\n        const freeSpace = (this.drawEnd.x - this.drawOrigin.x) / this.drawnFeatures.length * (1 - _constants__WEBPACK_IMPORTED_MODULE_0__.FREE_SPACE_FACTOR) / 4;\n        const axesEnds = [];\n        this.drawnFeatures.forEach((_, index) => {\n            const verticalX = this.drawOrigin.x + (index + 0.5) * boxSize + freeSpace;\n            axesEnds.push([new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(verticalX, this.drawOrigin.y), new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(verticalX, this.drawEnd.y)]);\n        });\n        return axesEnds;\n    }\n    horizontalAxesLocation() {\n        const drawHeight = this.drawEnd.y - this.drawOrigin.y;\n        const LOCAL_MIN_OFFSET_X = drawHeight - _constants__WEBPACK_IMPORTED_MODULE_0__.MIN_OFFSET_X * 1.2;\n        const firstEnds = [\n            new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawOrigin.x, this.drawEnd.y - 0.015 * drawHeight),\n            new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawEnd.x, this.drawEnd.y - 0.015 * drawHeight)\n        ];\n        const lastEnds = [\n            new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawOrigin.x, this.drawEnd.y - Math.min(0.9 * drawHeight, LOCAL_MIN_OFFSET_X)),\n            new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.drawEnd.x, this.drawEnd.y - Math.min(0.9 * drawHeight, LOCAL_MIN_OFFSET_X))\n        ];\n        const yStep = (lastEnds[0].y - firstEnds[0].y) / (this.drawnFeatures.length - 1);\n        const axesEnds = [firstEnds];\n        this.drawnFeatures.slice(1, this.drawnFeatures.length - 1).forEach((_, index) => {\n            axesEnds.push([\n                new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(firstEnds[0].x, firstEnds[0].y + (index + 1) * yStep),\n                new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(firstEnds[1].x, firstEnds[1].y + (index + 1) * yStep)\n            ]);\n        });\n        axesEnds.push(lastEnds);\n        return axesEnds;\n    }\n    computePoint(axis, featureValue) {\n        const xCoord = this.isVertical ? axis.origin.x : axis.relativeToAbsolute(featureValue);\n        const yCoord = this.isVertical ? axis.relativeToAbsolute(featureValue) : axis.origin.y;\n        return new _primitives__WEBPACK_IMPORTED_MODULE_5__.Point(xCoord, yCoord).scale(this.initScale);\n    }\n    computeCurves() {\n        this.curves = [];\n        for (let i = 0; i < this.nSamples; i++) {\n            const curve = new _primitives__WEBPACK_IMPORTED_MODULE_5__.LineSequence([], String(i));\n            this.drawnFeatures.forEach((feature, j) => curve.points.push(this.computePoint(this.axes[j], this.features.get(feature)[i])));\n            curve.hoveredThickener = curve.clickedThickener = 0;\n            curve.selectedThickener = 1;\n            this.curves.push(curve);\n        }\n    }\n    updateCurves() {\n        this.curves.forEach((curve, i) => {\n            var _a;\n            this.changedAxes.forEach(axis => {\n                const featureIndex = this.drawnFeatures.indexOf(axis.name);\n                curve.points[featureIndex] = this.computePoint(axis, this.features.get(axis.name)[i]);\n            });\n            curve.buildPath();\n            curve.isHovered = this.hoveredIndices.includes(i) && !this.isSelecting && !this.is_drawing_rubber_band;\n            curve.isClicked = this.clickedIndices.includes(i);\n            curve.isSelected = this.selectedIndices.includes(i);\n            curve.lineWidth = this.lineWidth;\n            curve.strokeStyle = (_a = this.getSetColorOfIndex(i)) !== null && _a !== void 0 ? _a : this.curveColor;\n        });\n    }\n    drawSelectionBox(context) { }\n    switchZoom() { }\n    drawCurves(context) {\n        const unpickedIndices = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.arrayDiff)(Array.from(Array(this.nSamples).keys()), [...this.hoveredIndices, ...this.clickedIndices, ...this.selectedIndices]);\n        unpickedIndices.forEach(i => this.curves[i].draw(context));\n        this.pointSets.forEach(pointSet => pointSet.indices.forEach(i => this.curves[i].draw(context)));\n        [this.selectedIndices, this.clickedIndices, this.hoveredIndices].forEach(indices => { for (let i of indices)\n            this.curves[i].draw(context); });\n    }\n    updateVisibleObjects(context) {\n        this.updateCurves();\n        this.drawCurves(context);\n    }\n    drawAbsoluteObjects(context) {\n        this.drawInZone(context);\n        this.absoluteObjects = new _collections__WEBPACK_IMPORTED_MODULE_8__.GroupCollection([...this.curves]);\n    }\n    drawTooltips() { }\n    mouseMove(canvasMouse, frameMouse, absoluteMouse) {\n        this.fixedObjects.mouseMove(this.context, canvasMouse);\n        if (!this.is_drawing_rubber_band) {\n            this.absoluteObjects.mouseMove(this.context, absoluteMouse);\n            this.relativeObjects.mouseMove(this.context, frameMouse);\n        }\n        ;\n        this.changeDisplayOrder();\n        this.hoveredIndices = this.absoluteObjects.updateShapeStates('isHovered');\n    }\n    changeDisplayOrder() {\n        if (this.isVertical)\n            this.axes.sort((a, b) => a.origin.x - b.origin.x);\n        else\n            this.axes.sort((a, b) => b.origin.y - a.origin.y);\n        this.drawnFeatures = this.axes.map((axis, i) => {\n            if (this.drawnFeatures[i] != axis.name)\n                axis.hasMoved = true;\n            return axis.name;\n        });\n    }\n    mouseUp(ctrlKey) {\n        if (this.changedAxes.length != 0)\n            this.updateAxesLocation();\n        super.mouseUp(ctrlKey);\n        if (this.changedAxes.length == 0)\n            this.clickedIndices = this.absoluteObjects.updateShapeStates('isClicked');\n    }\n    regulateScale() {\n        for (const axis of this.axes) {\n            if (axis.boundingBox.isHovered) {\n                this.regulateAxisScale(axis);\n                axis.update(this.axisStyle, this.viewPoint, new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.scaleX, this.scaleY), this.translation);\n                axis.saveLocation();\n                break;\n            }\n        }\n        this.scaleX = this.scaleY = 1;\n        this.viewPoint = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(0, 0);\n    }\n    updateAxes() {\n        const axesSelections = [];\n        this.axes.forEach(axis => {\n            if (axis.boundingBox.isClicked && !axis.isClicked)\n                axis.update(this.axisStyle, this.viewPoint, new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.scaleX, this.scaleY), this.translation);\n            if (axis.rubberBand.length != 0)\n                axesSelections.push(this.updateSelected(axis));\n        });\n        this.updateSelection(axesSelections);\n    }\n    axisChangeUpdate(e) { if (!this.changedAxes.includes(e))\n        this.changedAxes.push(e); }\n    resetMouseEvents() {\n        this.changedAxes = [];\n        return super.resetMouseEvents();\n    }\n}\nclass Draw extends Frame {\n    constructor(data, width, height, X, Y, canvasID, is_in_multiplot = false) {\n        super(data, width, height, X, Y, canvasID, is_in_multiplot);\n        this.width = width;\n        this.height = height;\n        this.canvasID = canvasID;\n        this.is_in_multiplot = is_in_multiplot;\n        this.is_in_multiplot = false;\n        this.relativeObjects = _collections__WEBPACK_IMPORTED_MODULE_8__.ShapeCollection.fromPrimitives(data.primitives, this.scale);\n    }\n    shiftOnAction(canvas) { }\n    setCanvas(canvasID) {\n        super.setCanvas(canvasID);\n        this.computeTextBorders(this.context);\n    }\n    resetScales() {\n        super.resetScales();\n        this.updateBounds();\n    }\n    reset() {\n        super.reset();\n        this.updateBounds();\n        this.draw();\n    }\n    resize() {\n        super.resize();\n        this.updateBounds();\n        this.axisEqual();\n    }\n    unpackData(data) {\n        const drawing = _collections__WEBPACK_IMPORTED_MODULE_8__.ShapeCollection.fromPrimitives(data.primitives);\n        const [minX, minY, maxX, maxY] = Draw.boundsDilatation(...drawing.getBounds());\n        const [xName, yName] = Draw.unpackAxesNames(data);\n        return new Map([[xName, [minX, maxX]], [yName, [minY, maxY]], [\"shapes\", drawing.shapes]]);\n    }\n    static unpackAxesNames(data) { var _a; return (_a = data.attribute_names) !== null && _a !== void 0 ? _a : [\"x\", \"y\"]; }\n    static boundsDilatation(minimum, maximum) {\n        const minX = minimum.x * (1 - Math.sign(minimum.x) * _constants__WEBPACK_IMPORTED_MODULE_0__.DRAW_MARGIN_FACTOR);\n        const minY = minimum.y * (1 - Math.sign(minimum.y) * _constants__WEBPACK_IMPORTED_MODULE_0__.DRAW_MARGIN_FACTOR);\n        const maxX = maximum.x * (1 + Math.sign(maximum.x) * _constants__WEBPACK_IMPORTED_MODULE_0__.DRAW_MARGIN_FACTOR);\n        const maxY = maximum.y * (1 + Math.sign(maximum.y) * _constants__WEBPACK_IMPORTED_MODULE_0__.DRAW_MARGIN_FACTOR);\n        return [minX, minY, maxX, maxY];\n    }\n    computeTextBorders(context) {\n        this.relativeObjects.updateBounds(context);\n        this.updateBounds();\n    }\n    updateBounds() {\n        const [minX, minY, maxX, maxY] = Draw.boundsDilatation(this.relativeObjects.minimum, this.relativeObjects.maximum);\n        this.axes[0].minValue = this.features.get(this.drawnFeatures[0])[0] = Math.min(this.features.get(this.drawnFeatures[0])[0], minX);\n        this.axes[1].minValue = this.features.get(this.drawnFeatures[1])[0] = Math.min(this.features.get(this.drawnFeatures[1])[1], minY);\n        this.axes[0].maxValue = this.features.get(this.drawnFeatures[0])[1] = Math.max(this.features.get(this.drawnFeatures[0])[0], maxX);\n        this.axes[1].maxValue = this.features.get(this.drawnFeatures[1])[1] = Math.max(this.features.get(this.drawnFeatures[1])[1], maxY);\n        this.axes.forEach(axis => axis.saveLocation());\n        this.axisEqual();\n    }\n    drawRelativeObjects(context) { this.drawInZone(context); }\n    updateVisibleObjects(context) {\n        this.relativeObjects.locateLabels(super.cuttingZone, this.initScale);\n        this.relativeObjects.draw(context);\n    }\n    get cuttingZone() {\n        const axesOrigin = this.axes[0].origin.transform(this.frameMatrix.inverse());\n        const axesEnd = new _baseShape__WEBPACK_IMPORTED_MODULE_4__.Vertex(this.axes[0].end.x, this.axes[1].end.y).transform(this.frameMatrix.inverse());\n        return new _primitives__WEBPACK_IMPORTED_MODULE_5__.Rect(axesOrigin, axesEnd.subtract(axesOrigin));\n    }\n    axisEqual() {\n        if (this.axes[0].drawScale > this.axes[1].drawScale)\n            this.axes[0].otherAxisScaling(this.axes[1]);\n        else\n            this.axes[1].otherAxisScaling(this.axes[0]);\n        this.axes.forEach(axis => axis.saveLocation());\n        this.updateAxes();\n    }\n    sendHoveredIndicesMultiplot() { return []; }\n    receiveMultiplotMouseIndices(multiplotHovered, multiplotClicked, multiplotSelected) { }\n    multiplotSelectedIntersection(multiplotSelected, isSelecting) { return [multiplotSelected, isSelecting]; }\n    receivePointSets(pointSets) { }\n    initRubberBandMultiplot(multiplotRubberBands) { }\n    updateRubberBandMultiplot(multiplotRubberBands) { }\n    sendRubberBandsMultiplot(figures) { }\n    receiveRubberBandFromFigure(figure) { }\n}\nclass PrimitiveGroupContainer extends Draw {\n    constructor(data, width, height, buttons_ON, X, Y, canvasID, is_in_multiplot = false) {\n        super(_constants__WEBPACK_IMPORTED_MODULE_0__.PG_CONTAINER_PLOT, width, height, X, Y, canvasID, is_in_multiplot);\n        this.width = width;\n        this.height = height;\n        this.buttons_ON = buttons_ON;\n        this.canvasID = canvasID;\n        this.is_in_multiplot = is_in_multiplot;\n    }\n}\n\n\n//# sourceURL=webpack://PlotData/./src/figures.ts?");

/***/ }),

/***/ "./src/functions.ts":
/*!**************************!*\
  !*** ./src/functions.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addInitZero\": () => (/* binding */ addInitZero),\n/* harmony export */   \"argMax\": () => (/* binding */ argMax),\n/* harmony export */   \"argMin\": () => (/* binding */ argMin),\n/* harmony export */   \"arrayDiff\": () => (/* binding */ arrayDiff),\n/* harmony export */   \"arrayIntersection\": () => (/* binding */ arrayIntersection),\n/* harmony export */   \"computeCanvasSize\": () => (/* binding */ computeCanvasSize),\n/* harmony export */   \"datesInDays\": () => (/* binding */ datesInDays),\n/* harmony export */   \"datesInHours\": () => (/* binding */ datesInHours),\n/* harmony export */   \"datesInMilliseconds\": () => (/* binding */ datesInMilliseconds),\n/* harmony export */   \"datesInMinutes\": () => (/* binding */ datesInMinutes),\n/* harmony export */   \"datesInSeconds\": () => (/* binding */ datesInSeconds),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"formatDateTicks\": () => (/* binding */ formatDateTicks),\n/* harmony export */   \"getTenPower\": () => (/* binding */ getTenPower),\n/* harmony export */   \"intersectArrays\": () => (/* binding */ intersectArrays),\n/* harmony export */   \"isInteger\": () => (/* binding */ isInteger),\n/* harmony export */   \"isIntegerArray\": () => (/* binding */ isIntegerArray),\n/* harmony export */   \"mapMax\": () => (/* binding */ mapMax),\n/* harmony export */   \"mapMin\": () => (/* binding */ mapMin),\n/* harmony export */   \"mean\": () => (/* binding */ mean),\n/* harmony export */   \"normalizeArray\": () => (/* binding */ normalizeArray),\n/* harmony export */   \"range\": () => (/* binding */ range),\n/* harmony export */   \"scaleArray\": () => (/* binding */ scaleArray),\n/* harmony export */   \"standardDeviation\": () => (/* binding */ standardDeviation),\n/* harmony export */   \"sum\": () => (/* binding */ sum),\n/* harmony export */   \"uniqueValues\": () => (/* binding */ uniqueValues)\n/* harmony export */ });\nfunction equals(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\n        if (a.constructor !== b.constructor)\n            return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!equals(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (a.constructor === RegExp)\n            return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf)\n            return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString)\n            return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!Object.prototype.hasOwnProperty.call(b, keys[i]))\n                return false;\n        for (i = length; i-- !== 0;) {\n            var key = keys[i];\n            if (!equals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n}\nfunction isInteger(value) {\n    return Math.floor(value) == value;\n}\nfunction isIntegerArray(array) {\n    return !array.some(value => !isInteger(value) && value != null);\n}\nfunction getTenPower(value) {\n    return value != 0 ? Math.floor(Math.log10(Math.abs(value))) : 0;\n}\nfunction uniqueValues(vector) {\n    return vector.filter((value, index, array) => array.indexOf(value) === index);\n}\nfunction addInitZero(value) {\n    const str = typeof value == \"number\" ? value.toString() : value;\n    return str.length == 1 ? `0${str}` : str;\n}\nfunction datesInMilliseconds(dateTicks) {\n    return dateTicks.map(tick => {\n        const date = new Date(tick);\n        return `${date.getMilliseconds()} ms`;\n    });\n}\nfunction datesInSeconds(dateTicks) {\n    return dateTicks.map(tick => {\n        const date = new Date(tick);\n        return `${date.getSeconds()}.${date.getMilliseconds()} s`;\n    });\n}\nfunction datesInMinutes(dateTicks) {\n    return dateTicks.map(tick => {\n        const date = new Date(tick);\n        return `${date.getMinutes()}:${date.getSeconds()} min`;\n    });\n}\nfunction datesInHours(dateTicks) {\n    return dateTicks.map(tick => {\n        const date = new Date(tick);\n        return `${addInitZero(date.getHours())}:${addInitZero(date.getMinutes())}:${addInitZero(date.getSeconds())}`;\n    });\n}\nfunction datesInDays(dateTicks) {\n    return dateTicks.map(tick => {\n        const date = new Date(tick);\n        return `${addInitZero(date.getDay() + 1)}/${addInitZero(date.getMonth() + 1)}/${date.getFullYear()} - ${addInitZero(date.getHours())}:${addInitZero(date.getMinutes())}:${addInitZero(date.getSeconds())}`;\n    });\n}\nfunction formatDateTicks(dateTicks) {\n    const min = Math.min(...dateTicks);\n    const interval = Math.max(...dateTicks) - min;\n    if (interval <= 1000)\n        return datesInMilliseconds(dateTicks);\n    if (interval <= 60000)\n        return datesInSeconds(dateTicks);\n    if (interval <= 360000)\n        return datesInMinutes(dateTicks);\n    if (interval <= 8640000)\n        return datesInHours(dateTicks);\n    return datesInDays(dateTicks);\n}\nfunction arrayDiff(a, b) {\n    if (b.length == 0)\n        return a;\n    return a.filter(value => !b.includes(value));\n}\nfunction arrayIntersection(a, b) {\n    return a.filter(value => b.includes(value));\n}\nfunction intersectArrays(arrays) {\n    if (arrays.length == 1)\n        return arrays[0];\n    if (arrays.length == 0)\n        return [];\n    const arraysIntersection = [];\n    const allValues = [].concat(...arrays);\n    allValues.forEach(value => {\n        let inAllArrays = true;\n        for (let i = 0; i < arrays.length; i++) {\n            if (!arrays[i].includes(value)) {\n                inAllArrays = false;\n                break;\n            }\n        }\n        if (inAllArrays)\n            arraysIntersection.push(value);\n    });\n    return uniqueValues(arraysIntersection);\n}\nfunction computeCanvasSize(buttonContainerName) {\n    var _a;\n    const buttonsContainer = (_a = document.querySelector(buttonContainerName)) !== null && _a !== void 0 ? _a : document.getElementById(buttonContainerName);\n    if (buttonsContainer)\n        return [0.95 * window.innerWidth, 0.95 * window.innerHeight - buttonsContainer.scrollHeight];\n    return [0.95 * window.innerWidth, 0.95 * window.innerHeight];\n}\nfunction range(start, end, step = 1) {\n    let array = [];\n    if (start < end)\n        for (let i = start; i < end; i = i + step)\n            array.push(i);\n    if (start > end)\n        for (let i = start; i > end; i = i + step)\n            array.push(i);\n    return array;\n}\nfunction mean(array) {\n    if (!array)\n        return 0;\n    if (array.length == 0)\n        return 0;\n    let sum = 0;\n    array.forEach(value => sum += value);\n    return sum / array.length;\n}\nfunction standardDeviation(array) {\n    if (!array)\n        return [0, 0];\n    if (array.length == 0)\n        return [0, 0];\n    const arrayMean = mean(array);\n    let sum = 0;\n    array.forEach(value => sum += (value - arrayMean) ** 2);\n    return [Math.sqrt(sum / array.length), arrayMean];\n}\nfunction scaleArray(array) {\n    if (!array)\n        return array;\n    const [std, mean] = standardDeviation(array);\n    return Array.from(array, x => (x - mean) / (std == 0 ? 1 : std));\n}\nfunction normalizeArray(array) {\n    const maxAbs = Math.max(...array.map(x => Math.abs(x)));\n    return array.map(x => x / maxAbs);\n}\nfunction argMin(array) {\n    let min = Number.POSITIVE_INFINITY;\n    let argMin = -1;\n    array.forEach((value, index) => {\n        if (value < min) {\n            min = value;\n            argMin = index;\n        }\n    });\n    return [min, argMin];\n}\nfunction argMax(array) {\n    let max = Number.NEGATIVE_INFINITY;\n    let argMax = -1;\n    array.forEach((value, index) => {\n        if (value > max) {\n            max = value;\n            argMax = index;\n        }\n    });\n    return [max, argMax];\n}\nfunction mapMin(map) {\n    let min = Number.POSITIVE_INFINITY;\n    let keyMin = null;\n    map.forEach((value, key) => {\n        if (value <= min) {\n            min = value;\n            keyMin = key;\n        }\n    });\n    return [keyMin, min];\n}\nfunction mapMax(map) {\n    let max = Number.NEGATIVE_INFINITY;\n    let keyMax = null;\n    map.forEach((value, key) => {\n        if (value >= max) {\n            max = value;\n            keyMax = key;\n        }\n    });\n    return [keyMax, max];\n}\nfunction sum(array) {\n    let sum = 0;\n    array.forEach(value => sum += value);\n    return sum;\n}\n\n\n//# sourceURL=webpack://PlotData/./src/functions.ts?");

/***/ }),

/***/ "./src/multiplot.ts":
/*!**************************!*\
  !*** ./src/multiplot.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Multiplot\": () => (/* binding */ Multiplot)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions */ \"./src/functions.ts\");\n/* harmony import */ var _baseShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./baseShape */ \"./src/baseShape.ts\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shapes */ \"./src/shapes.ts\");\n/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./collections */ \"./src/collections.ts\");\n/* harmony import */ var _figures__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./figures */ \"./src/figures.ts\");\n\n\n\n\n\n\n/*\nTODO: Does this inherit from RemoteFigure or the opposite or does this\ninherit from InteractiveObject or from nothing ?\n*/\nclass Multiplot {\n    constructor(data, width, height, canvasID) {\n        this.width = width;\n        this.height = height;\n        this.canvasID = canvasID;\n        this.figureZones = new _collections__WEBPACK_IMPORTED_MODULE_4__.SelectionBoxCollection([]);\n        this.isSelecting = false;\n        this.isZooming = false;\n        this.isResizing = false;\n        this.hoveredFigureIndex = 0;\n        this.clickedFigureIndex = null;\n        this.hiddenFigureIndices = [];\n        this.clickedIndices = [];\n        this.hoveredIndices = [];\n        this.selectedIndices = [];\n        this.buildCanvas(canvasID);\n        [this.features, this.figures] = this.unpackData(data);\n        this.featureNames = Array.from(this.features.keys());\n        this.nSamples = this.features.entries().next().value[1].length;\n        this.computeTable();\n        this.draw();\n        this.initRubberBands();\n        this.mouseListener();\n    }\n    unpackData(data) {\n        const features = _figures__WEBPACK_IMPORTED_MODULE_5__.Figure.deserializeData(data);\n        const figures = [];\n        if (data.plots.length == 0)\n            figures.push(this.newEmptyPlot(_constants__WEBPACK_IMPORTED_MODULE_0__.EMPTY_MULTIPLOT));\n        else {\n            data.plots.forEach(plot => {\n                const localData = { ...plot, \"elements\": data.elements, \"points_sets\": data.points_sets };\n                const newPlot = _figures__WEBPACK_IMPORTED_MODULE_5__.Figure.fromMultiplot(localData, this.width, this.height, this.canvasID);\n                if (!(newPlot instanceof _figures__WEBPACK_IMPORTED_MODULE_5__.Graph2D))\n                    this.pointSets = newPlot.pointSets;\n                if (!(newPlot instanceof _figures__WEBPACK_IMPORTED_MODULE_5__.Graph2D || newPlot instanceof _figures__WEBPACK_IMPORTED_MODULE_5__.Draw))\n                    newPlot.features = features;\n                newPlot.context = this.context;\n                figures.push(newPlot);\n            });\n        }\n        return [features, figures];\n    }\n    serializeFeatures() {\n        const elements = [];\n        for (let i = 0; i < this.nSamples; i++) {\n            const newSample = {};\n            this.featureNames.forEach(feature => newSample[feature] = this.features.get(feature)[i]);\n            newSample[\"values\"] = { ...newSample };\n            elements.push(newSample);\n        }\n        return elements;\n    }\n    newEmptyPlot(data) {\n        const figure = new _figures__WEBPACK_IMPORTED_MODULE_5__.Draw(data, this.width, this.height, 0, 0, this.canvasID);\n        figure.context = this.context;\n        return figure;\n    }\n    buildCanvas(canvasID) {\n        this.canvas = document.getElementById(canvasID);\n        this.canvas.width = this.width;\n        this.canvas.height = this.height;\n        this.context = this.canvas.getContext(\"2d\");\n    }\n    computeTable() {\n        const sqrtNPlots = this.figures.length ** 0.5;\n        const ratio = Number.isInteger(sqrtNPlots) ? sqrtNPlots : Math.ceil(this.width > this.height ? this.width / this.height : this.height / this.width);\n        const nRows = Math.ceil(this.figures.length / ratio);\n        const nCols = Math.ceil(this.figures.length / nRows);\n        const height = this.height / nRows;\n        const width = this.width / nCols;\n        let k = 0;\n        for (let j = 0; j < nCols; j++) {\n            const xCoord = j * width;\n            for (let i = 0; i < nRows; i++) {\n                const yCoord = i * height;\n                this.figures[k].multiplotDraw(new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(xCoord + _constants__WEBPACK_IMPORTED_MODULE_0__.FIGURES_BLANK_SPACE, yCoord + _constants__WEBPACK_IMPORTED_MODULE_0__.FIGURES_BLANK_SPACE), width - _constants__WEBPACK_IMPORTED_MODULE_0__.FIGURES_BLANK_SPACE * 2, height - _constants__WEBPACK_IMPORTED_MODULE_0__.FIGURES_BLANK_SPACE * 2);\n                k++;\n                if (k == this.figures.length)\n                    break;\n            }\n        }\n    }\n    draw() {\n        this.context.clearRect(0, 0, this.width, this.height);\n        this.figures.forEach((figure, index) => {\n            figure.receiveMultiplotMouseIndices(this.hoveredIndices, this.clickedIndices, this.selectedIndices);\n            figure.receivePointSets(this.pointSets);\n            if (!this.hiddenFigureIndices.includes(index))\n                figure.draw();\n        });\n        this.drawZoneRectangles();\n    }\n    addParallelPlot(featureNames) {\n        const data = { type_: \"parallelplot\", attribute_names: featureNames, elements: this.serializeFeatures() };\n        this.addFigure(_figures__WEBPACK_IMPORTED_MODULE_5__.ParallelPlot.createFromMultiplot(data, this.features, this.context, this.canvasID));\n    }\n    addScatter(xFeature, yFeature) {\n        const data = { type_: \"scatterplot\", attribute_names: [xFeature, yFeature], elements: this.serializeFeatures() };\n        this.addFigure(_figures__WEBPACK_IMPORTED_MODULE_5__.Scatter.createFromMultiplot(data, this.features, this.context, this.canvasID));\n    }\n    addFigure(figure) {\n        this.figures.push(figure);\n        this.figureZones.shapes = [];\n        this.activateAxisEvents(figure);\n        this.resetLayout();\n    }\n    deleteFigure(index) {\n        this.figures.splice(index, 1);\n        this.figureZones.removeShape(index);\n        this.resetLayout();\n    }\n    hideFigure(index) { this.hiddenFigureIndices.push(index); }\n    showFigure(index) { this.hiddenFigureIndices.splice(this.hiddenFigureIndices.indexOf(index), 1); }\n    toggleFigure(index) {\n        this.hiddenFigureIndices.includes(index)\n            ? this.showFigure(index)\n            : this.hideFigure(index);\n        this.draw();\n    }\n    toggleAxes(index) {\n        this.figures[index].toggleAxes();\n        this.draw();\n    }\n    htmlToggleAxes() { var _a; this.toggleAxes((_a = this.clickedFigureIndex) !== null && _a !== void 0 ? _a : this.hoveredFigureIndex); }\n    resetLayout() {\n        this.computeTable();\n        if (this.figureZones.shapes.length != 0) {\n            this.figures.forEach((figure, index) => this.figureZones.shapes[index].updateRectangle(figure.origin, figure.size));\n        }\n        this.draw();\n    }\n    activateAxisEvents(figure) {\n        figure.axes.forEach(axis => axis.emitter.on('axisStateChange', e => figure.axisChangeUpdate(e)));\n        figure.axes.forEach((axis, index) => {\n            axis.emitter.on('rubberBandChange', e => {\n                figure.activateSelection(e, index);\n                this.isSelecting = true;\n            });\n        });\n    }\n    selectionOn() {\n        this.isSelecting = true;\n        this.figures.forEach(figure => figure.isSelecting = true);\n        this.canvas.style.cursor = 'crosshair';\n    }\n    selectionOff() {\n        if (this.isSelecting)\n            this.canvas.style.cursor = 'default';\n        this.isSelecting = false;\n        this.figures.forEach(figure => {\n            figure.isSelecting = false;\n            figure.is_drawing_rubber_band = false;\n        });\n    }\n    switchSelection() {\n        this.isSelecting ? this.selectionOff() : this.selectionOn();\n    }\n    switchMerge() { this.figures.forEach(figure => figure.switchMerge()); }\n    switchResize() {\n        this.isResizing = !this.isResizing;\n        this.canvas.style.cursor = 'default';\n        this.draw();\n    }\n    drawZoneRectangles() {\n        if (this.isResizing) {\n            if (this.figureZones.shapes.length == 0) {\n                const figureZones = this.figures.map(figure => figure.drawZoneRectangle(this.context));\n                this.figureZones = new _collections__WEBPACK_IMPORTED_MODULE_4__.SelectionBoxCollection(figureZones);\n            }\n            else\n                this.figureZones.draw(this.context);\n        }\n    }\n    togglePoints() { this.figures.forEach(figure => figure.togglePoints()); }\n    zoomOn() {\n        this.isZooming = true;\n        this.figures.forEach(figure => figure.isZooming = true);\n        this.canvas.style.cursor = 'crosshair';\n    }\n    zoomOff() {\n        if (this.isZooming)\n            this.canvas.style.cursor = 'default';\n        this.isZooming = false;\n        this.figures.forEach(figure => figure.isZooming = false);\n    }\n    switchZoom() {\n        this.isZooming ? this.zoomOff() : this.zoomOn();\n    }\n    zoomIn() { var _a; (this.figures[(_a = this.clickedFigureIndex) !== null && _a !== void 0 ? _a : this.hoveredFigureIndex]).zoomIn(); }\n    zoomOut() { var _a; (this.figures[(_a = this.clickedFigureIndex) !== null && _a !== void 0 ? _a : this.hoveredFigureIndex]).zoomOut(); }\n    simpleCluster(inputValue) { this.figures.forEach(figure => figure.simpleCluster(inputValue)); }\n    ;\n    resetClusters() { this.figures.forEach(figure => figure.resetClusters()); }\n    ;\n    resetView() {\n        this.figures.forEach(figure => figure.resetView());\n        this.draw();\n    }\n    reset() {\n        this.clickedIndices = [];\n        this.hoveredIndices = [];\n        this.resetSelection();\n        this.figures.forEach(figure => figure.reset());\n        this.draw();\n    }\n    resetSelection() {\n        this.resetRubberBands();\n        this.selectedIndices = [];\n        this.draw();\n    }\n    switchOrientation() { this.figures.forEach(figure => figure.switchOrientation()); }\n    resize(width, height) {\n        const widthRatio = width / this.width;\n        const heightRatio = height / this.height;\n        this.figures.forEach((figure, index) => {\n            figure.boundingBoxResize(figure.origin.scale(new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(widthRatio, heightRatio)), figure.size.x * widthRatio, figure.size.y * heightRatio);\n            if (this.figureZones.shapes.length != 0)\n                this.figureZones.shapes[index].updateRectangle(figure.origin, figure.size);\n        });\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.width = width;\n        this.height = height;\n        this.draw();\n    }\n    addPointSet(pointSet) { this.pointSets.push(pointSet); }\n    removePointSet(index) { this.pointSets.splice(index, 1); }\n    addPointsToSet(pointIndices, setIndex) {\n        this.pointSets[setIndex].indices.push(...pointIndices);\n        this.pointSets[setIndex].indices = Array.from(new Set(this.pointSets[setIndex].indices));\n    }\n    removePointsFromSet(pointIndices, setIndex) {\n        this.pointSets[setIndex].indices = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.arrayDiff)(this.pointSets[setIndex].indices, pointIndices);\n    }\n    updateSelectedIndices() {\n        const previousIndices = [...this.selectedIndices];\n        this.selectedIndices = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.range)(0, this.nSamples);\n        let isSelecting = false;\n        this.figures.forEach(figure => [this.selectedIndices, isSelecting] = figure.multiplotSelectedIntersection(this.selectedIndices, isSelecting));\n        if (this.selectedIndices.length == this.nSamples && !isSelecting)\n            this.selectedIndices = [];\n        if (!(0,_functions__WEBPACK_IMPORTED_MODULE_1__.equals)(previousIndices, this.selectedIndices))\n            this.emitSelectionChange();\n    }\n    emitSelectionChange() {\n        this.canvas.dispatchEvent(new CustomEvent('selectionchange', { detail: { 'selectedIndices': this.selectedIndices } }));\n    }\n    updateHoveredIndices(figure) { this.hoveredIndices = figure.sendHoveredIndicesMultiplot(); }\n    initRubberBands() {\n        this.rubberBands = new Map();\n        this.figures.forEach(figure => figure.initRubberBandMultiplot(this.rubberBands));\n    }\n    updateRubberBands(currentFigure) {\n        if (this.isSelecting) {\n            if (!this.rubberBands)\n                this.initRubberBands();\n            currentFigure.sendRubberBandsMultiplot(this.figures);\n            this.figures.forEach(figure => figure.updateRubberBandMultiplot(this.rubberBands));\n        }\n    }\n    resetRubberBands() {\n        this.rubberBands.forEach(rubberBand => rubberBand.reset());\n        this.figures.forEach(figure => figure.resetRubberBands());\n    }\n    listenAxisStateChange() {\n        this.figures.forEach(figure => figure.axes.forEach(axis => axis.emitter.on('axisStateChange', e => figure.axisChangeUpdate(e))));\n    }\n    listenRubberBandChange() {\n        this.figures.forEach(figure => {\n            figure.axes.forEach((axis, index) => {\n                axis.emitter.on('rubberBandChange', e => {\n                    figure.activateSelection(e, index);\n                    this.isSelecting = true;\n                });\n            });\n        });\n    }\n    keyDownDrawer(e, ctrlKey, shiftKey, spaceKey) {\n        if (e.key == \"Control\") {\n            ctrlKey = true;\n            this.canvas.style.cursor = 'default';\n            if (shiftKey)\n                this.figures.forEach(figure => figure.keyUpDrawer(this.canvas, \"Shift\", ctrlKey, shiftKey, spaceKey));\n        }\n        if (e.key == \"Shift\") {\n            shiftKey = true;\n            if (!ctrlKey) {\n                this.canvas.style.cursor = 'crosshair';\n                this.isSelecting = true;\n                this.figures.forEach(figure => figure.keyDownDrawer(this.canvas, e.key, ctrlKey, shiftKey, spaceKey));\n            }\n        }\n        if (e.key == \" \") {\n            spaceKey = true;\n        }\n        this.figures[this.hoveredFigureIndex].keyDownDrawer(this.canvas, e.key, ctrlKey, shiftKey, spaceKey);\n        return [ctrlKey, shiftKey, spaceKey];\n    }\n    keyUpDrawer(e, ctrlKey, shiftKey, spaceKey) {\n        if (e.key == \"Shift\") {\n            shiftKey = false;\n            this.isSelecting = false;\n        }\n        if (e.key == \"Control\") {\n            ctrlKey = false;\n            if (shiftKey) {\n                this.canvas.style.cursor = 'crosshair';\n                this.figures.forEach(figure => figure.keyDownDrawer(this.canvas, \"Shift\", ctrlKey, shiftKey, spaceKey));\n            }\n        }\n        if (e.key == \" \")\n            spaceKey = false;\n        this.figures.forEach(figure => figure.keyUpDrawer(this.canvas, e.key, ctrlKey, shiftKey, spaceKey));\n        return [ctrlKey, shiftKey, spaceKey];\n    }\n    getHoveredIndex(mouseCoords) {\n        for (const [index, figure] of this.figures.entries()) {\n            if (figure.isInCanvas(mouseCoords)) {\n                this.hoveredFigureIndex = index;\n                break;\n            }\n        }\n    }\n    mouseLeaveFigure(figure, shiftKey) {\n        figure.mouseLeaveDrawer(this.canvas, shiftKey);\n        return [null, true];\n    }\n    zoneToFigure(mouseCoords, clickedZone) {\n        for (let [i, figureZone] of this.figureZones.shapes.entries()) {\n            if (figureZone === clickedZone)\n                this.clickedFigureIndex = i;\n        }\n        clickedZone.mouseMove(this.context, mouseCoords);\n        clickedZone.buildRectangle(new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(0, 0), new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(this.width, this.height));\n        this.figures[this.clickedFigureIndex].boundingBoxResize(clickedZone.origin, clickedZone.size.x, clickedZone.size.y);\n    }\n    resizeWithMouse(mouseCoords, clickedObject) {\n        if (clickedObject instanceof _shapes__WEBPACK_IMPORTED_MODULE_3__.SelectionBox)\n            this.zoneToFigure(mouseCoords, clickedObject);\n        else\n            this.figureZones.mouseMove(this.context, mouseCoords);\n    }\n    mouseMoveDrawer(e, hasLeftFigure, canvasMouse, frameMouse, canvasDown, frameDown, clickedObject, shiftKey) {\n        e.preventDefault();\n        let absoluteMouse = new _baseShape__WEBPACK_IMPORTED_MODULE_2__.Vertex(e.offsetX, e.offsetY);\n        this.getHoveredIndex(absoluteMouse);\n        if (!this.isResizing) {\n            if (this.clickedFigureIndex != null && canvasDown) {\n                if (!this.figures[this.clickedFigureIndex].isInCanvas(absoluteMouse))\n                    [canvasDown, hasLeftFigure] = this.mouseLeaveFigure(this.figures[this.clickedFigureIndex], shiftKey);\n            }\n            if (!hasLeftFigure)\n                [canvasMouse, frameMouse, absoluteMouse] = this.figures[this.hoveredFigureIndex].mouseMoveDrawer(this.canvas, e, canvasDown, frameDown, clickedObject);\n        }\n        else\n            this.resizeWithMouse(absoluteMouse, clickedObject);\n        this.updateHoveredIndices(this.figures[this.hoveredFigureIndex]);\n        this.updateRubberBands(this.figures[this.hoveredFigureIndex]);\n        this.updateSelectedIndices();\n        return [canvasMouse, frameMouse, absoluteMouse, canvasDown, hasLeftFigure];\n    }\n    mouseDownDrawer(canvasMouse, frameMouse, absoluteMouse) {\n        this.clickedFigureIndex = this.hoveredFigureIndex;\n        if (this.isResizing)\n            return [null, null, this.figureZones.mouseDown(absoluteMouse.copy())];\n        return this.figures[this.hoveredFigureIndex].mouseDownDrawer(canvasMouse, frameMouse, absoluteMouse);\n    }\n    mouseUpDrawer(canvasDown, clickedObject, ctrlKey, shiftKey, hasLeftFigure) {\n        if (this.isResizing && clickedObject instanceof _shapes__WEBPACK_IMPORTED_MODULE_3__.SelectionBox)\n            clickedObject.mouseUp(ctrlKey);\n        if (!hasLeftFigure && !this.isResizing)\n            [clickedObject, canvasDown] = this.figures[this.hoveredFigureIndex].mouseUpDrawer(ctrlKey);\n        if (!(this.figures[this.hoveredFigureIndex] instanceof _figures__WEBPACK_IMPORTED_MODULE_5__.Graph2D || this.figures[this.hoveredFigureIndex] instanceof _figures__WEBPACK_IMPORTED_MODULE_5__.Draw)) {\n            this.clickedIndices = this.figures[this.hoveredFigureIndex].clickedIndices;\n        }\n        this.updateRubberBands(this.figures[this.hoveredFigureIndex]);\n        hasLeftFigure = this.resetStateAttributes(shiftKey, ctrlKey);\n        clickedObject = null;\n        this.updateSelectedIndices();\n        return [canvasDown, clickedObject, hasLeftFigure];\n    }\n    mouseWheelDrawer(e) {\n        e.preventDefault();\n        this.figures[this.hoveredFigureIndex].mouseWheelDrawer(e);\n    }\n    mouseLeaveDrawer() {\n        this.resetStateAttributes(false, false);\n        return [null, true];\n    }\n    mouseEnterDrawer() { return [null, false]; }\n    mouseListener() {\n        // TODO: mouseListener generally suffers from a bad initial design that should be totally rethink in a specific refactor development\n        let ctrlKey = false;\n        let shiftKey = false;\n        let spaceKey = false;\n        let clickedObject = null;\n        let canvasMouse = null;\n        let frameMouse = null;\n        let absoluteMouse = null;\n        let canvasDown = null;\n        let frameDown = null;\n        let hasLeftFigure = false;\n        this.listenAxisStateChange();\n        this.listenRubberBandChange();\n        window.addEventListener('keydown', e => [ctrlKey, shiftKey, spaceKey] = this.keyDownDrawer(e, ctrlKey, shiftKey, spaceKey));\n        window.addEventListener('keyup', e => [ctrlKey, shiftKey, spaceKey] = this.keyUpDrawer(e, ctrlKey, shiftKey, spaceKey));\n        this.canvas.addEventListener('mousemove', e => {\n            [canvasMouse, frameMouse, absoluteMouse, canvasDown, hasLeftFigure] = this.mouseMoveDrawer(e, hasLeftFigure, canvasMouse, frameMouse, canvasDown, frameDown, clickedObject, shiftKey);\n            this.draw();\n        });\n        this.canvas.addEventListener('mousedown', () => [canvasDown, frameDown, clickedObject] = this.mouseDownDrawer(canvasMouse, frameMouse, absoluteMouse));\n        this.canvas.addEventListener('mouseup', () => {\n            [canvasDown, clickedObject, hasLeftFigure] = this.mouseUpDrawer(canvasDown, clickedObject, ctrlKey, shiftKey, hasLeftFigure);\n            this.draw();\n            this.zoomOff();\n        });\n        this.canvas.addEventListener('wheel', e => {\n            this.mouseWheelDrawer(e);\n            this.draw();\n        });\n        this.canvas.addEventListener(\"mouseleave\", () => [canvasDown, hasLeftFigure] = this.mouseLeaveDrawer());\n        this.canvas.addEventListener(\"mouseenter\", () => [canvasDown, hasLeftFigure] = this.mouseEnterDrawer());\n    }\n    resetStateAttributes(shiftKey, ctrlKey) {\n        if (ctrlKey && shiftKey)\n            this.reset();\n        if (!this.isZooming && !this.isSelecting)\n            this.canvas.style.cursor = 'default';\n        if (!shiftKey)\n            this.selectionOff();\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://PlotData/./src/multiplot.ts?");

/***/ }),

/***/ "./src/old.ts":
/*!********************!*\
  !*** ./src/old.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"List\": () => (/* binding */ List)\n/* harmony export */ });\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions */ \"./src/functions.ts\");\n// REQUIRED IN WORKFLOW BUILDER APP\n// MUST BE REMOVED BY WRITING USED METHODS IN WORKFLOW BUILDER (CAUSE UNUSED IN PLOT_DATA)\n\nclass List {\n    static subarray(list, i, j) { return list.slice(i, j); }\n    static remove_duplicates(list) {\n        var seen = {};\n        var out = [];\n        var len = list.length;\n        var j = 0;\n        for (var i = 0; i < len; i++) {\n            var item = list[i];\n            if (seen[item] !== 1) {\n                seen[item] = 1;\n                out[j++] = item;\n            }\n        }\n        return out;\n    }\n    static contains_undefined(list) {\n        for (var i = 0; i < list.length; i++) {\n            if (typeof list[i] === \"undefined\") {\n                return true;\n            }\n        }\n        return false;\n    }\n    static copy(list) {\n        var new_list = [];\n        for (var i = 0; i < list.length; i++) {\n            new_list.push(list[i]);\n        }\n        return new_list;\n    }\n    static remove_first_selection(val, list) {\n        var temp = [];\n        var bool = true;\n        for (var i = 0; i < list.length; i++) {\n            var d = list[i];\n            if ((val != d) && bool) {\n                temp.push(d);\n                bool = false;\n            }\n        }\n        return temp;\n    }\n    static equals(list1, list2) {\n        return list1.toString() === list2.toString();\n    }\n    static remove_element(val, list) {\n        return list.filter(elt => elt !== val);\n    }\n    static is_include(val, list) {\n        return list.findIndex(elt => (0,_functions__WEBPACK_IMPORTED_MODULE_0__.equals)(elt, val)) !== -1;\n    }\n    static is_list_include(list, listArray) {\n        for (let i = 0; i < listArray.length; i++) {\n            if (this.equals(listArray[i], list)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static is_name_include(name, obj_list) {\n        for (let i = 0; i < obj_list.length; i++) {\n            if (name === obj_list[i].name) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static getExtremum(list) {\n        var min = list[0];\n        var max = list[0];\n        for (let i = 0; i < list.length; i++) {\n            if (list[i] >= max) {\n                max = list[i];\n            }\n            ;\n            if (list[i] <= min) {\n                min = list[i];\n            }\n            ;\n        }\n        return [min, max];\n    }\n    static insert(value, index, list) {\n        list.splice(index, 0, value);\n    }\n    static get_index_of_element(val, list) {\n        var elt_index = list.findIndex(obj => Object.is(obj, val));\n        if (elt_index !== -1) {\n            return elt_index;\n        }\n        throw new Error('cannot get index of element');\n    }\n    static remove_at_index(i, list) {\n        return list.slice(0, i).concat(list.slice(i + 1, list.length));\n    }\n    static remove_at_indices(start_index, end_index, list) {\n        if (start_index > end_index)\n            throw new Error('remove_indices(): start_index must be <= end_index');\n        if (start_index < 0 || end_index >= list.length)\n            throw new Error('remove_indices(): index out of range');\n        for (let i = 0; i <= end_index - start_index; i++) {\n            list = this.remove_at_index(start_index, list);\n        }\n        return list;\n    }\n    static move_elements(old_index, new_index, list) {\n        var elt = list[old_index];\n        if (old_index < new_index) {\n            list.splice(new_index + 1, 0, elt);\n            list = this.remove_at_index(old_index, list);\n        }\n        else {\n            list.splice(new_index, 0, elt);\n            list = this.remove_at_index(old_index + 1, list);\n        }\n        return list;\n    }\n    static switchElements(list, index1, index2) {\n        [list[index1], list[index2]] = [list[index2], list[index1]];\n    }\n    static reverse(list) { return Array.from(list).reverse(); }\n    static isListOfEmptyList(list) {\n        for (let i = 0; i < list.length; i++) {\n            if (list[i].length !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static listIntersection(list1, list2) {\n        return list1.filter(value => list2.includes(value));\n    }\n    static listIntersectionExceptEmpty(list1, list2) {\n        if (list1.length === 0)\n            return list2;\n        if (list2.length === 0)\n            return list1;\n        return list1.filter(value => list2.includes(value));\n    }\n    static getListEltFromIndex(list_index, list) {\n        var new_list = [];\n        for (let i = 0; i < list_index.length; i++) {\n            new_list.push(list[list_index[i]]);\n        }\n        return new_list;\n    }\n    static union(list1, list2) {\n        var union_list = this.copy(list1);\n        for (let i = 0; i < list2.length; i++) {\n            if (!this.is_include(list2[i], union_list)) {\n                union_list.push(list2[i]);\n            }\n        }\n        return union_list;\n    }\n    static remove_selection(to_remove, list) {\n        var new_list = Array.from(list);\n        for (let val of to_remove) {\n            new_list = List.remove_element(val, new_list);\n        }\n        return new_list;\n    }\n}\n\n\n//# sourceURL=webpack://PlotData/./src/old.ts?");

/***/ }),

/***/ "./src/primitives.ts":
/*!***************************!*\
  !*** ./src/primitives.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbstractHalfLine\": () => (/* binding */ AbstractHalfLine),\n/* harmony export */   \"AbstractLinePoint\": () => (/* binding */ AbstractLinePoint),\n/* harmony export */   \"AbstractTriangle\": () => (/* binding */ AbstractTriangle),\n/* harmony export */   \"Arc\": () => (/* binding */ Arc),\n/* harmony export */   \"Circle\": () => (/* binding */ Circle),\n/* harmony export */   \"Contour\": () => (/* binding */ Contour),\n/* harmony export */   \"Cross\": () => (/* binding */ Cross),\n/* harmony export */   \"DownHalfLine\": () => (/* binding */ DownHalfLine),\n/* harmony export */   \"DownTriangle\": () => (/* binding */ DownTriangle),\n/* harmony export */   \"HalfLine\": () => (/* binding */ HalfLine),\n/* harmony export */   \"HorizontalLinePoint\": () => (/* binding */ HorizontalLinePoint),\n/* harmony export */   \"LeftHalfLine\": () => (/* binding */ LeftHalfLine),\n/* harmony export */   \"LeftTriangle\": () => (/* binding */ LeftTriangle),\n/* harmony export */   \"Line\": () => (/* binding */ Line),\n/* harmony export */   \"LinePoint\": () => (/* binding */ LinePoint),\n/* harmony export */   \"LineSegment\": () => (/* binding */ LineSegment),\n/* harmony export */   \"LineSequence\": () => (/* binding */ LineSequence),\n/* harmony export */   \"Mark\": () => (/* binding */ Mark),\n/* harmony export */   \"NegativeLinePoint\": () => (/* binding */ NegativeLinePoint),\n/* harmony export */   \"Point\": () => (/* binding */ Point),\n/* harmony export */   \"PositiveLinePoint\": () => (/* binding */ PositiveLinePoint),\n/* harmony export */   \"Rect\": () => (/* binding */ Rect),\n/* harmony export */   \"RightHalfLine\": () => (/* binding */ RightHalfLine),\n/* harmony export */   \"RightTriangle\": () => (/* binding */ RightTriangle),\n/* harmony export */   \"RoundRect\": () => (/* binding */ RoundRect),\n/* harmony export */   \"Triangle\": () => (/* binding */ Triangle),\n/* harmony export */   \"UpHalfLine\": () => (/* binding */ UpHalfLine),\n/* harmony export */   \"UpTriangle\": () => (/* binding */ UpTriangle),\n/* harmony export */   \"VerticalLinePoint\": () => (/* binding */ VerticalLinePoint)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _baseShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./baseShape */ \"./src/baseShape.ts\");\n\n\nclass Arc extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(center, radius, startAngle, endAngle, clockWise = true) {\n        super();\n        this.center = center;\n        this.radius = radius;\n        this.startAngle = startAngle;\n        this.endAngle = endAngle;\n        this.clockWise = clockWise;\n        this.isFilled = false;\n        this.buildPath();\n    }\n    buildPath() {\n        this.path = new Path2D();\n        this.drawInContour(this.path);\n    }\n    drawInContour(path) {\n        path.arc(this.center.x, this.center.y, this.radius, this.startAngle, this.endAngle, this.clockWise);\n    }\n    static deserialize(data, scale) {\n        var _a;\n        return new Arc(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.cx, data.cy), data.r, data.start_angle, data.end_angle, (_a = data.clockwise) !== null && _a !== void 0 ? _a : true);\n    }\n    getBounds() {\n        return [\n            new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.center.x - this.radius, this.center.y - this.radius),\n            new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.center.x + this.radius, this.center.y + this.radius)\n        ];\n    }\n}\nclass Circle extends Arc {\n    constructor(center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), radius = 1) {\n        super(center, radius, 0, 2 * Math.PI);\n        this.center = center;\n        this.radius = radius;\n        this.isFilled = true;\n    }\n    static deserialize(data, scale) {\n        return new Circle(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.cx, data.cy), data.r);\n    }\n}\nclass Rect extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(origin = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0)) {\n        super();\n        this.origin = origin;\n        this.size = size;\n        this.buildPath();\n    }\n    get area() { return this.size.x * this.size.y; }\n    get center() { return this.origin.add(this.size.divide(2)); }\n    buildPath() {\n        this.path = new Path2D();\n        this.path.rect(this.origin.x, this.origin.y, this.size.x, this.size.y);\n    }\n    static deserialize(data, scale) {\n        return new Rect(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.x_coord, data.y_coord), new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.width, data.height));\n    }\n    translate(translation) {\n        this.origin = this.origin.add(translation);\n        this.buildPath();\n    }\n    getBounds() { return [this.origin, this.origin.add(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(Math.abs(this.size.x), Math.abs(this.size.y)))]; }\n}\nclass RoundRect extends Rect {\n    constructor(origin = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), radius = 2) {\n        super();\n        this.origin = origin;\n        this.size = size;\n        this.radius = radius;\n        this.buildPath();\n    }\n    buildPath() {\n        this.path = new Path2D();\n        const hLength = this.origin.x + this.size.x;\n        const vLength = this.origin.y + this.size.y;\n        this.path.moveTo(this.origin.x + this.radius, this.origin.y);\n        this.path.lineTo(hLength - this.radius, this.origin.y);\n        this.path.quadraticCurveTo(hLength, this.origin.y, hLength, this.origin.y + this.radius);\n        this.path.lineTo(hLength, this.origin.y + this.size.y - this.radius);\n        this.path.quadraticCurveTo(hLength, vLength, hLength - this.radius, vLength);\n        this.path.lineTo(this.origin.x + this.radius, vLength);\n        this.path.quadraticCurveTo(this.origin.x, vLength, this.origin.x, vLength - this.radius);\n        this.path.lineTo(this.origin.x, this.origin.y + this.radius);\n        this.path.quadraticCurveTo(this.origin.x, this.origin.y, this.origin.x + this.radius, this.origin.y);\n    }\n    static deserialize(data, scale) {\n        return new RoundRect(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.x_coord, data.y_coord), new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.width, data.height), data.radius);\n    }\n}\nclass Mark extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = 1) {\n        super();\n        this.center = center;\n        this.size = size;\n        this.isFilled = false;\n        this.buildPath();\n    }\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x - halfSize, this.center.y);\n        this.path.lineTo(this.center.x + halfSize, this.center.y);\n        this.path.moveTo(this.center.x, this.center.y - halfSize);\n        this.path.lineTo(this.center.x, this.center.y + halfSize);\n    }\n    getBounds() {\n        const halfSize = this.size / 2;\n        const halfSizeVertex = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(halfSize, halfSize);\n        return [this.center.subtract(halfSizeVertex), this.center.add(halfSizeVertex)];\n    }\n}\nclass AbstractHalfLine extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = 1, orientation = 'up') {\n        super();\n        this.center = center;\n        this.size = size;\n        this.orientation = orientation;\n        this.isFilled = false;\n        this.buildPath();\n    }\n    get drawingStyle() {\n        return { ...super.drawingStyle, \"orientation\": this.orientation };\n    }\n    getBounds() {\n        const halfSize = this.size / 2;\n        const halfSizeVertex = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(halfSize, halfSize);\n        return [this.center.subtract(halfSizeVertex), this.center.add(halfSizeVertex)];\n    }\n}\nclass UpHalfLine extends AbstractHalfLine {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x, this.center.y);\n        this.path.lineTo(this.center.x, this.center.y + halfSize);\n    }\n}\nclass DownHalfLine extends AbstractHalfLine {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x, this.center.y);\n        this.path.lineTo(this.center.x, this.center.y - halfSize);\n    }\n}\nclass LeftHalfLine extends AbstractHalfLine {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x, this.center.y);\n        this.path.lineTo(this.center.x - halfSize, this.center.y);\n    }\n}\nclass RightHalfLine extends AbstractHalfLine {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x, this.center.y);\n        this.path.lineTo(this.center.x + halfSize, this.center.y);\n    }\n}\nclass HalfLine extends AbstractHalfLine {\n    constructor(center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = 1, orientation = 'up') {\n        super(center, size, orientation);\n        this.center = center;\n        this.size = size;\n        this.orientation = orientation;\n        this.buildPath();\n    }\n    buildPath() {\n        if (this.orientation == 'up')\n            this.path = new UpHalfLine(this.center, this.size).path;\n        if (this.orientation == 'down')\n            this.path = new DownHalfLine(this.center, this.size).path;\n        if (this.orientation == 'left')\n            this.path = new LeftHalfLine(this.center, this.size).path;\n        if (this.orientation == 'right')\n            this.path = new RightHalfLine(this.center, this.size).path;\n        if (!['up', 'down', 'left', 'right'].includes(this.orientation))\n            throw new Error(`Orientation halfline ${this.orientation} is unknown.`);\n    }\n}\nclass Line extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(origin = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), end = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0)) {\n        super();\n        this.origin = origin;\n        this.end = end;\n        this.isFilled = false;\n        this.buildPath();\n    }\n    computeSlope() {\n        return (this.end.y - this.origin.y) / (this.end.x - this.origin.x);\n    }\n    computeAffinity(slope) {\n        return this.origin.y - slope * this.origin.x;\n    }\n    getEquation() {\n        const slope = this.computeSlope();\n        const affinity = this.computeAffinity(slope);\n        return [slope, affinity];\n    }\n    static deserialize(data, scale) {\n        return new Line(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.point1[0], data.point1[1]), new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.point2[0], data.point2[1]));\n    }\n    buildPath() {\n        const [slope, affinity] = this.getEquation();\n        if (this.end.x == this.origin.x) {\n            this.path = new LineSegment(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.origin.x, -this.end.y * _constants__WEBPACK_IMPORTED_MODULE_0__.INFINITE_LINE_FACTOR), new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.origin.x, this.end.y * _constants__WEBPACK_IMPORTED_MODULE_0__.INFINITE_LINE_FACTOR)).path;\n        }\n        else {\n            const fakeOrigin = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(-_constants__WEBPACK_IMPORTED_MODULE_0__.INFINITE_LINE_FACTOR, 0);\n            const fakeEnd = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(_constants__WEBPACK_IMPORTED_MODULE_0__.INFINITE_LINE_FACTOR, 0);\n            if (this.origin.x != 0) {\n                fakeOrigin.x *= this.origin.x;\n                fakeEnd.x *= this.origin.x;\n            }\n            fakeOrigin.y = fakeOrigin.x * slope + affinity;\n            fakeEnd.y = fakeEnd.x * slope + affinity;\n            this.path = new LineSegment(fakeOrigin, fakeEnd).path;\n        }\n    }\n    getBounds() {\n        const minX = Math.min(this.origin.x, this.end.x);\n        const minY = Math.min(this.origin.y, this.end.y);\n        const maxX = Math.max(this.origin.x, this.end.x);\n        const maxY = Math.max(this.origin.y, this.end.y);\n        return [new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(minX, minY), new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(maxX, maxY)];\n    }\n}\nclass LineSegment extends Line {\n    constructor(origin = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), end = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0)) {\n        super(origin, end);\n        this.origin = origin;\n        this.end = end;\n    }\n    buildPath() {\n        this.path = new Path2D();\n        this.path.moveTo(this.origin.x, this.origin.y);\n        this.drawInContour(this.path);\n    }\n    static deserialize(data, scale) {\n        return new LineSegment(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.point1[0], data.point1[1]), new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.point2[0], data.point2[1]));\n    }\n    drawInContour(path) { path.lineTo(this.end.x, this.end.y); }\n}\nclass AbstractLinePoint extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = 1, orientation = 'up') {\n        super();\n        this.center = center;\n        this.size = size;\n        this.orientation = orientation;\n        this.isFilled = false;\n        this.buildPath();\n    }\n    get drawingStyle() {\n        return { ...super.drawingStyle, \"orientation\": this.orientation };\n    }\n    getBounds() {\n        const halfSize = this.size / 2;\n        const halfSizeVertex = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(halfSize, halfSize);\n        return [this.center.subtract(halfSizeVertex), this.center.add(halfSizeVertex)];\n    }\n}\nclass VerticalLinePoint extends AbstractLinePoint {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x, this.center.y - halfSize);\n        this.path.lineTo(this.center.x, this.center.y + halfSize);\n    }\n}\nclass HorizontalLinePoint extends AbstractLinePoint {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x - halfSize, this.center.y);\n        this.path.lineTo(this.center.x + halfSize, this.center.y);\n    }\n}\nclass PositiveLinePoint extends AbstractLinePoint {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x - halfSize, this.center.y - halfSize);\n        this.path.lineTo(this.center.x + halfSize, this.center.y + halfSize);\n    }\n}\nclass NegativeLinePoint extends AbstractLinePoint {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x - halfSize, this.center.y + halfSize);\n        this.path.lineTo(this.center.x + halfSize, this.center.y - halfSize);\n    }\n}\nclass LinePoint extends AbstractLinePoint {\n    constructor(center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = 1, orientation = 'vertical') {\n        super(center, size, orientation);\n        this.center = center;\n        this.size = size;\n        this.orientation = orientation;\n        this.buildPath();\n    }\n    buildPath() {\n        if (this.orientation == 'vertical')\n            this.path = new VerticalLinePoint(this.center, this.size).path;\n        if (this.orientation == 'horizontal')\n            this.path = new HorizontalLinePoint(this.center, this.size).path;\n        if (['slash', 'positive'].includes(this.orientation))\n            this.path = new PositiveLinePoint(this.center, this.size).path;\n        if (['backslash', 'negative'].includes(this.orientation))\n            this.path = new NegativeLinePoint(this.center, this.size).path;\n        if (!['vertical', 'horizontal', 'slash', 'backslash', 'positive', 'negative'].includes(this.orientation))\n            throw new Error(`Orientation ${this.orientation} is unknown.`);\n    }\n}\nclass Cross extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = 1) {\n        super();\n        this.center = center;\n        this.size = size;\n        this.isFilled = false;\n        this.buildPath();\n    }\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x - halfSize, this.center.y - halfSize);\n        this.path.lineTo(this.center.x + halfSize, this.center.y + halfSize);\n        this.path.moveTo(this.center.x - halfSize, this.center.y + halfSize);\n        this.path.lineTo(this.center.x + halfSize, this.center.y - halfSize);\n    }\n    getBounds() {\n        const halfSize = this.size / 2;\n        const halfSizeVertex = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(halfSize, halfSize);\n        return [this.center.subtract(halfSizeVertex), this.center.add(halfSizeVertex)];\n    }\n}\nclass AbstractTriangle extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = 1, orientation = 'up') {\n        super();\n        this.center = center;\n        this.size = size;\n        this.orientation = orientation;\n        this.buildPath();\n    }\n    get drawingStyle() {\n        return { ...super.drawingStyle, \"orientation\": this.orientation };\n    }\n    getBounds() {\n        const halfSize = this.size / 2;\n        const halfSizeVertex = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(halfSize, halfSize);\n        return [this.center.subtract(halfSizeVertex), this.center.add(halfSizeVertex)];\n    }\n}\nclass UpTriangle extends AbstractTriangle {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x - halfSize, this.center.y - halfSize);\n        this.path.lineTo(this.center.x + halfSize, this.center.y - halfSize);\n        this.path.lineTo(this.center.x, this.center.y + halfSize);\n        this.path.closePath();\n    }\n}\nclass DownTriangle extends AbstractTriangle {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x + halfSize, this.center.y + halfSize);\n        this.path.lineTo(this.center.x, this.center.y - halfSize);\n        this.path.lineTo(this.center.x - halfSize, this.center.y + halfSize);\n        this.path.closePath();\n    }\n}\nclass LeftTriangle extends AbstractTriangle {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x + halfSize, this.center.y - halfSize);\n        this.path.lineTo(this.center.x - halfSize, this.center.y);\n        this.path.lineTo(this.center.x + halfSize, this.center.y + halfSize);\n        this.path.closePath();\n    }\n}\nclass RightTriangle extends AbstractTriangle {\n    buildPath() {\n        this.path = new Path2D();\n        const halfSize = this.size / 2;\n        this.path.moveTo(this.center.x - halfSize, this.center.y - halfSize);\n        this.path.lineTo(this.center.x + halfSize, this.center.y);\n        this.path.lineTo(this.center.x - halfSize, this.center.y + halfSize);\n        this.path.closePath();\n    }\n}\nclass Triangle extends AbstractTriangle {\n    constructor(center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = 1, orientation = 'up') {\n        super();\n        this.center = center;\n        this.size = size;\n        this.orientation = orientation;\n        this.buildPath();\n    }\n    buildPath() {\n        if (this.orientation == 'up')\n            this.path = new UpTriangle(this.center, this.size).path;\n        if (this.orientation == 'down')\n            this.path = new DownTriangle(this.center, this.size).path;\n        if (this.orientation == 'right')\n            this.path = new RightTriangle(this.center, this.size).path;\n        if (this.orientation == 'left')\n            this.path = new LeftTriangle(this.center, this.size).path;\n        if (!['up', 'down', 'left', 'right'].includes(this.orientation))\n            throw new Error(`Orientation ${this.orientation} is unknown.`);\n    }\n}\nclass Contour extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(lines = [], isFilled = false) {\n        super();\n        this.lines = lines;\n        this.isFilled = isFilled;\n        this.buildPath();\n    }\n    static deserialize(data, scale) {\n        var _a;\n        const lines = data.plot_data_primitives.map(primitive => {\n            if (primitive.type_ == \"arc\")\n                return Arc.deserialize(primitive, scale);\n            if (primitive.type_ == \"linesegment2d\")\n                return LineSegment.deserialize(primitive, scale);\n            if (primitive.type_ == \"circle\")\n                return Circle.deserialize(primitive, scale);\n            if (primitive.type_ == \"line2d\")\n                return Line.deserialize(primitive, scale);\n            throw new Error(`Type ${primitive.type_} is unknown in Contour.`);\n        });\n        return new Contour(lines, (_a = data.is_filled) !== null && _a !== void 0 ? _a : false);\n    }\n    setDrawingProperties(context) {\n        super.setDrawingProperties(context);\n        context.strokeStyle = \"hsla(0, 0%, 100%, 0)\";\n        this.lines.forEach(line => this.setLineStyle(line));\n    }\n    setLineStyle(line) {\n        var _a;\n        line.dashLine = line.dashLine.length != 0 ? line.dashLine : this.dashLine;\n        line.strokeStyle = (_a = line.strokeStyle) !== null && _a !== void 0 ? _a : this.strokeStyle;\n        line.lineWidth = line.lineWidth != 1 ? line.lineWidth : this.lineWidth;\n        line.isHovered = this.isHovered;\n        line.isClicked = this.isClicked;\n        line.isSelected = this.isSelected;\n    }\n    drawLines(context) {\n        this.lines.forEach(line => line.draw(context));\n    }\n    drawMembers(context) { this.drawLines(context); }\n    buildPath() {\n        this.path = new Path2D();\n        if (this.lines[0] instanceof LineSegment)\n            this.path.moveTo(this.lines[0].origin.x, this.lines[0].origin.y);\n        this.lines.forEach(line => line.drawInContour(this.path));\n        if (this.isFilled)\n            this.path.closePath();\n    }\n    getBounds() {\n        let minimum = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        let maximum = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n        this.lines.forEach(line => {\n            const [shapeMin, shapeMax] = line.getBounds();\n            if (shapeMin.x <= minimum.x)\n                minimum.x = shapeMin.x;\n            if (shapeMin.y <= minimum.y)\n                minimum.y = shapeMin.y;\n            if (shapeMax.x >= maximum.x)\n                maximum.x = shapeMax.x;\n            if (shapeMax.y >= maximum.y)\n                maximum.y = shapeMax.y;\n        });\n        return [minimum, maximum];\n    }\n}\nclass Point extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(x = 0, y = 0, _size = 12, _marker = 'circle', _markerOrientation = 'up', fillStyle = null, strokeStyle = null) {\n        super();\n        this._size = _size;\n        this._marker = _marker;\n        this._markerOrientation = _markerOrientation;\n        this.isScaled = false;\n        this.center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(x, y);\n        this.buildPath();\n        this.fillStyle = fillStyle || this.fillStyle;\n        this.strokeStyle = strokeStyle || this.setStrokeStyle(this.fillStyle);\n        this.lineWidth = 1;\n    }\n    ;\n    get tooltipFlip() { return true; }\n    get drawingStyle() {\n        const style = super.drawingStyle;\n        style[\"markerOrientation\"] = this.markerOrientation;\n        style[\"marker\"] = this.marker;\n        style[\"size\"] = this.size;\n        return style;\n    }\n    getBounds() {\n        const factor = 0.025;\n        const minX = this.center.x != 0 ? this.center.x - Math.abs(this.center.x) * factor : -1;\n        const minY = this.center.y != 0 ? this.center.y - Math.abs(this.center.y) * factor : -1;\n        const maxX = this.center.x != 0 ? this.center.x + Math.abs(this.center.x) * factor : 1;\n        const maxY = this.center.y != 0 ? this.center.y + Math.abs(this.center.y) * factor : 1;\n        return [new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(minX, minY), new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(maxX, maxY)];\n    }\n    static deserialize(data, scale) {\n        return new Point(data.cx, data.cy);\n    }\n    deserializeStyle(data) {\n        var _a;\n        this.deserializeTooltip(data);\n        this.deserializePointStyle((_a = data.point_style) !== null && _a !== void 0 ? _a : {});\n    }\n    deserializePointStyle(data) {\n        var _a, _b, _c, _d, _e, _f;\n        this.size = (_a = data.size) !== null && _a !== void 0 ? _a : this.size;\n        this.fillStyle = (_b = data.color_fill) !== null && _b !== void 0 ? _b : this.fillStyle;\n        this.strokeStyle = (_c = data.color_stroke) !== null && _c !== void 0 ? _c : this.strokeStyle;\n        this.lineWidth = (_d = data.stroke_width) !== null && _d !== void 0 ? _d : this.lineWidth;\n        this.marker = (_e = data.shape) !== null && _e !== void 0 ? _e : this.marker;\n        this.markerOrientation = (_f = data.orientation) !== null && _f !== void 0 ? _f : this.markerOrientation;\n    }\n    updateStyle(style) {\n        var _a, _b, _c, _d, _e, _f;\n        this.size = (_a = style.size) !== null && _a !== void 0 ? _a : this.size;\n        this.fillStyle = (_b = style.fillStyle) !== null && _b !== void 0 ? _b : this.fillStyle;\n        this.strokeStyle = (_c = style.strokeStyle) !== null && _c !== void 0 ? _c : this.strokeStyle;\n        this.lineWidth = (_d = style.lineWidth) !== null && _d !== void 0 ? _d : this.lineWidth;\n        this.marker = (_e = style.marker) !== null && _e !== void 0 ? _e : this.marker;\n        this.markerOrientation = (_f = style.orientation) !== null && _f !== void 0 ? _f : this.markerOrientation;\n    }\n    copy() {\n        const copy = new Point();\n        copy.center = this.center.copy();\n        copy.size = this.size;\n        copy.marker = this.marker;\n        copy.markerOrientation = this.markerOrientation;\n        copy.fillStyle = this.fillStyle;\n        copy.strokeStyle = this.strokeStyle;\n        copy.lineWidth = this.lineWidth;\n        return copy;\n    }\n    update() { this.buildPath(); }\n    scale(scale) {\n        this.center = this.center.scale(scale);\n        this.buildPath();\n        return this;\n    }\n    setColors(color) {\n        this.fillStyle = this.isFilled ? color : null;\n        this.strokeStyle = this.isFilled ? this.setStrokeStyle(this.fillStyle) : color;\n    }\n    get drawnShape() {\n        let marker = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape();\n        if (_constants__WEBPACK_IMPORTED_MODULE_0__.CIRCLES.includes(this.marker))\n            marker = new Circle(this.center, this.size / 2);\n        if (_constants__WEBPACK_IMPORTED_MODULE_0__.MARKERS.includes(this.marker))\n            marker = new Mark(this.center, this.size);\n        if (_constants__WEBPACK_IMPORTED_MODULE_0__.CROSSES.includes(this.marker))\n            marker = new Cross(this.center, this.size);\n        if (_constants__WEBPACK_IMPORTED_MODULE_0__.SQUARES.includes(this.marker)) {\n            const halfSize = this.size * 0.5;\n            const origin = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.center.x - halfSize, this.center.y - halfSize);\n            marker = new Rect(origin, new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.size, this.size));\n        }\n        ;\n        if (_constants__WEBPACK_IMPORTED_MODULE_0__.TRIANGLES.includes(this.marker))\n            marker = new Triangle(this.center, this.size, this.markerOrientation);\n        if (_constants__WEBPACK_IMPORTED_MODULE_0__.HALF_LINES.includes(this.marker))\n            marker = new HalfLine(this.center, this.size, this.markerOrientation);\n        if (this.marker == 'line')\n            marker = new LinePoint(this.center, this.size, this.markerOrientation);\n        marker.lineWidth = this.lineWidth;\n        this.isFilled = marker.isFilled;\n        return marker;\n    }\n    updateTooltipOrigin(matrix) { this.tooltipOrigin = this.center.copy(); }\n    get markerOrientation() { return this._markerOrientation; }\n    ;\n    set markerOrientation(value) { this._markerOrientation = value; }\n    ;\n    get size() { return this._size; }\n    ;\n    set size(value) { this._size = value; }\n    ;\n    get marker() { return this._marker; }\n    ;\n    set marker(value) { this._marker = value; }\n    ;\n    buildPath() { this.path = this.drawnShape.path; }\n    buildUnscaledPath(context) {\n        const matrix = context.getTransform();\n        context.resetTransform();\n        const center = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(matrix.e, matrix.f).add(this.center.scale(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(matrix.a, matrix.d))).subtract(this.center);\n        const path = new Path2D();\n        path.addPath(this.drawnShape.path, new DOMMatrix([1, 0, 0, 1, center.x, center.y]));\n        this.path = new Path2D();\n        this.path.addPath(path, matrix.inverse());\n        return path;\n    }\n    isInFrame(origin, end, scale) {\n        const inCanvasX = this.center.x * scale.x < end.x && this.center.x * scale.x > origin.x;\n        const inCanvasY = this.center.y * scale.y < end.y && this.center.y * scale.y > origin.y;\n        this.inFrame = inCanvasX && inCanvasY;\n        return this.inFrame;\n    }\n    isPointInStroke(context, point) {\n        const contextMatrix = context.getTransform();\n        this.setContextPointInStroke(context);\n        const isHovered = context.isPointInStroke(this.path, point.x, point.y);\n        context.setTransform(contextMatrix);\n        return isHovered;\n    }\n    setContextPointInStroke(context) { context.resetTransform(); }\n}\nclass LineSequence extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(points = [], name = \"\") {\n        super();\n        this.points = points;\n        this.name = name;\n        this.hoveredThickener = 2;\n        this.clickedThickener = 2;\n        this.selectedThickener = 2;\n        this.isFilled = false;\n        this.isScaled = true;\n        this.updateTooltipMap();\n        this.buildPath();\n    }\n    static deserialize(data, scale) {\n        var _a;\n        const points = data.lines.map(line => new Point(line[0], line[1]));\n        return new LineSequence(points, (_a = data.name) !== null && _a !== void 0 ? _a : \"\");\n    }\n    initTooltipOrigin() {\n        if (!this.tooltipOrigin)\n            this.tooltipOrigin = this.points[Math.floor(this.points.length / 2)].center;\n    }\n    getBounds() {\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n        this.points.forEach(point => {\n            if (point.center.x < minX)\n                minX = point.center.x;\n            if (point.center.y < minY)\n                minY = point.center.y;\n            if (point.center.x > maxX)\n                maxX = point.center.x;\n            if (point.center.y > maxY)\n                maxY = point.center.y;\n        });\n        return [new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(minX, minY), new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(maxX, maxY)];\n    }\n    mouseDown(mouseDown) {\n        super.mouseDown(mouseDown);\n        if (this.isHovered)\n            this.previousMouseClick = mouseDown.copy();\n    }\n    updateTooltipMap() { this._tooltipMap = new Map(this.name ? [[\"Name\", this.name]] : []); }\n    static unpackGraphProperties(graph) {\n        const emptyLineSequence = new LineSequence([], graph.name);\n        emptyLineSequence.deserializeEdgeStyle(graph);\n        return emptyLineSequence;\n    }\n    setDrawingProperties(context) {\n        super.setDrawingProperties(context);\n        const thickener = this.isSelected ? this.selectedThickener : this.isClicked ? this.clickedThickener : this.isHovered ? this.hoveredThickener : 0;\n        context.lineWidth = this.lineWidth + thickener;\n    }\n    buildPath() {\n        if (this.points.length > 0) {\n            this.path = new Path2D();\n            this.path.moveTo(this.points[0].center.x, this.points[0].center.y);\n            this.points.slice(1).forEach(point => this.path.lineTo(point.center.x, point.center.y));\n        }\n    }\n    update(points) {\n        this.points = points;\n        this.buildPath();\n    }\n}\n\n\n//# sourceURL=webpack://PlotData/./src/primitives.ts?");

/***/ }),

/***/ "./src/remoteFigure.ts":
/*!*****************************!*\
  !*** ./src/remoteFigure.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RemoteFigure\": () => (/* binding */ RemoteFigure)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions */ \"./src/functions.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n/* harmony import */ var _baseShape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./baseShape */ \"./src/baseShape.ts\");\n/* harmony import */ var _primitives__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./primitives */ \"./src/primitives.ts\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shapes */ \"./src/shapes.ts\");\n/* harmony import */ var _axes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./axes */ \"./src/axes.ts\");\n/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./collections */ \"./src/collections.ts\");\n\n\n\n\n\n\n\n\nclass RemoteFigure {\n    constructor(data, width, height, X, Y, canvasID, is_in_multiplot = false) {\n        this.width = width;\n        this.height = height;\n        this.canvasID = canvasID;\n        this.is_in_multiplot = is_in_multiplot;\n        this.axes = [];\n        this.translation = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(0, 0);\n        this.pointSets = [];\n        this.pointStyles = null;\n        this.lineWidth = 1;\n        this.isHovered = false;\n        this.isSelecting = false;\n        this.selectionBox = new _shapes__WEBPACK_IMPORTED_MODULE_5__.SelectionBox();\n        this.isZooming = false;\n        this.zoomBox = new _shapes__WEBPACK_IMPORTED_MODULE_5__.SelectionBox();\n        this.viewPoint = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(0, 0);\n        this.font = \"sans-serif\";\n        this.initScale = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(1, -1);\n        this._axisStyle = new Map([['strokeStyle', 'hsl(0, 0%, 30%)']]);\n        this.MAX_PRINTED_NUMBERS = 10;\n        this.TRL_THRESHOLD = 20;\n        // TODO: refactor these legacy attribute\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.is_drawing_rubber_band = false;\n        this.unpackAxisStyle(data);\n        this.origin = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(X, Y);\n        this.size = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(width - X, height - Y);\n        this.features = this.unpackData(data);\n        this.featureNames = Array.from(this.features.keys());\n        this.nSamples = this.features.entries().next().value[1].length;\n        this.initSelectors();\n        this.scaleX = this.scaleY = 1;\n        this.TRL_THRESHOLD /= Math.min(Math.abs(this.initScale.x), Math.abs(this.initScale.y));\n        this.buildPointSets(data);\n        this.drawnFeatures = this.setFeatures(data);\n        this.axes = this.setAxes();\n        this.fixedObjects = new _collections__WEBPACK_IMPORTED_MODULE_7__.ShapeCollection(this.axes);\n        this.relativeObjects = new _collections__WEBPACK_IMPORTED_MODULE_7__.GroupCollection();\n        this.absoluteObjects = new _collections__WEBPACK_IMPORTED_MODULE_7__.GroupCollection();\n    }\n    get scale() { return new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.relativeMatrix.a, this.relativeMatrix.d); }\n    set axisStyle(newAxisStyle) { newAxisStyle.forEach((value, key) => this._axisStyle.set(key, value)); }\n    get axisStyle() { return this._axisStyle; }\n    get canvasMatrix() { return new DOMMatrix([this.initScale.x, 0, 0, this.initScale.y, 0, 0]); }\n    get relativeMatrix() { return new DOMMatrix([this.initScale.x, 0, 0, this.initScale.y, 0, 0]); }\n    get offsetFactor() { var _a; return (_a = this._offsetFactor) !== null && _a !== void 0 ? _a : new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(0.027, 0.035); }\n    get marginFactor() { var _a; return (_a = this._marginFactor) !== null && _a !== void 0 ? _a : new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(0.01, 0.02); }\n    isInCanvas(vertex) {\n        return vertex.x >= this.origin.x && vertex.x <= this.origin.x + this.size.x && vertex.y >= this.origin.y && vertex.y <= this.origin.y + this.size.y;\n    }\n    unpackAxisStyle(data) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if ((_b = (_a = data.axis) === null || _a === void 0 ? void 0 : _a.axis_style) === null || _b === void 0 ? void 0 : _b.color_stroke)\n            this.axisStyle.set(\"strokeStyle\", data.axis.axis_style.color_stroke);\n        if ((_d = (_c = data.axis) === null || _c === void 0 ? void 0 : _c.axis_style) === null || _d === void 0 ? void 0 : _d.line_width)\n            this.axisStyle.set(\"lineWidth\", data.axis.axis_style.line_width);\n        if ((_f = (_e = data.axis) === null || _e === void 0 ? void 0 : _e.graduation_style) === null || _f === void 0 ? void 0 : _f.font_style)\n            this.axisStyle.set(\"font\", data.axis.graduation_style.font_style);\n        if ((_h = (_g = data.axis) === null || _g === void 0 ? void 0 : _g.graduation_style) === null || _h === void 0 ? void 0 : _h.font_size)\n            this.axisStyle.set(\"ticksFontsize\", data.axis.graduation_style.font_size);\n    }\n    unpackPointsSets(data) {\n        if (data.points_sets) {\n            this.pointSets = data.points_sets.map((pointSet, index) => {\n                var _a;\n                const name = (_a = pointSet.name) !== null && _a !== void 0 ? _a : `Point set ${index}`;\n                return new _collections__WEBPACK_IMPORTED_MODULE_7__.PointSet(pointSet.indices, (0,_colors__WEBPACK_IMPORTED_MODULE_2__.colorHsl)(pointSet.color), name);\n            });\n        }\n    }\n    unpackData(data) { return RemoteFigure.deserializeData(data); }\n    serializeFeatures() {\n        const elements = [];\n        for (let i = 0; i < this.nSamples; i++) {\n            const newSample = { \"values\": {} };\n            this.featureNames.forEach(feature => {\n                newSample[feature] = this.features.get(feature)[i];\n                if (feature != \"name\")\n                    newSample[\"values\"][feature] = newSample[feature];\n            });\n            elements.push(newSample);\n        }\n        return elements;\n    }\n    buildPointSets(data) { this.unpackPointsSets(data); }\n    getSetColorOfIndex(index) {\n        for (let set of this.pointSets) {\n            if (set.indices.includes(index))\n                return set.color;\n        }\n        return null;\n    }\n    static deserializeData(data) {\n        const unpackedData = new Map();\n        if (data.x_variable)\n            unpackedData.set(data.x_variable, []);\n        if (!data.elements) {\n            unpackedData.set(\"x\", []);\n            unpackedData.set(\"y\", []);\n            return unpackedData;\n        }\n        ;\n        const featureKeys = data.elements.length ? Array.from(Object.keys(data.elements[0].values)) : [];\n        featureKeys.push(\"name\");\n        featureKeys.forEach(feature => unpackedData.set(feature, data.elements.map(element => RemoteFigure.deserializeValue(element[feature]))));\n        return unpackedData;\n    }\n    static deserializeValue(value) {\n        if (typeof value == \"string\") {\n            if (value.includes(\"gmt+\"))\n                return new Date(Number(value.split(\"gmt+\")[0]));\n        }\n        return value;\n    }\n    drawBorders() {\n        const rect = new _primitives__WEBPACK_IMPORTED_MODULE_4__.Rect(this.origin, this.size);\n        rect.lineWidth = 0.5;\n        rect.strokeStyle = \"hsl(0, 0%, 83%)\";\n        rect.isFilled = false;\n        rect.draw(this.context);\n    }\n    drawCanvas() {\n        this.context.clearRect(this.origin.x - 1, this.origin.y - 1, this.width + 2, this.height + 2);\n    }\n    setCanvas(canvasID) {\n        const canvas = document.getElementById(canvasID);\n        canvas.width = this.width;\n        canvas.height = this.height;\n        this.context = canvas.getContext(\"2d\");\n    }\n    updateAxes() {\n        const axesSelections = [];\n        this.axes.forEach(axis => {\n            axis.update(this.axisStyle, this.viewPoint, new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.scaleX, this.scaleY), this.translation);\n            if (axis.rubberBand.length != 0)\n                axesSelections.push(this.updateSelected(axis));\n        });\n        this.updateSelection(axesSelections);\n    }\n    changeAxisFeature(name, index) {\n        this.drawnFeatures[index] = name;\n        this.axes[index] = this.setAxis(name, this.axes[index].boundingBox, this.axes[index].origin, this.axes[index].end, this.axes[index].nTicks);\n        this.resetScales();\n        this.draw();\n    }\n    setFeatures(data) { var _a; return (_a = data.attribute_names) !== null && _a !== void 0 ? _a : Array.from(this.features.keys()); }\n    computeNaturalOffset() { return new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.width * this.offsetFactor.x, this.height * this.offsetFactor.y); }\n    computeOffset() {\n        const naturalOffset = this.computeNaturalOffset();\n        return new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(Math.max(naturalOffset.x, _constants__WEBPACK_IMPORTED_MODULE_0__.MIN_OFFSET_X) + _constants__WEBPACK_IMPORTED_MODULE_0__.AXES_BLANK_SPACE, Math.max(naturalOffset.y, _constants__WEBPACK_IMPORTED_MODULE_0__.MIN_OFFSET_Y));\n    }\n    get marginOffset() { return new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(_constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END, _constants__WEBPACK_IMPORTED_MODULE_0__.SIZE_AXIS_END); }\n    setBounds() {\n        this.offset = this.computeOffset();\n        this.margin = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.size.x * this.marginFactor.x, this.size.y * this.marginFactor.y).add(this.marginOffset);\n        return this.computeBounds();\n    }\n    computeBounds() {\n        const canvasOrigin = this.origin.scale(this.initScale);\n        this.drawOrigin = this.offset.add(canvasOrigin);\n        this.drawEnd = canvasOrigin.add(this.size.subtract(this.margin));\n        const freeSpace = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(Math.abs(this.drawOrigin.x - this.origin.x), Math.abs(this.drawOrigin.y - this.origin.y));\n        if (this.canvasMatrix.a < 0)\n            this.swapDimension(\"x\", this.drawOrigin, this.drawEnd, freeSpace);\n        if (this.canvasMatrix.d < 0)\n            this.swapDimension(\"y\", this.drawOrigin, this.drawEnd, freeSpace);\n        return freeSpace;\n    }\n    swapDimension(dimension, origin, end, freeSpace) {\n        origin[dimension] = origin[dimension] - this.size[dimension];\n        end[dimension] = end[dimension] - this.size[dimension];\n        freeSpace[dimension] = Math.abs(this.origin[dimension] - origin[dimension] * this.initScale[dimension] + this.size[dimension]);\n    }\n    setAxes() {\n        const freeSpace = this.setBounds();\n        const axisBoundingBoxes = this.buildAxisBoundingBoxes(freeSpace);\n        return this.buildAxes(axisBoundingBoxes);\n    }\n    buildAxisBoundingBoxes(freeSpace) { return []; }\n    buildAxes(axisBoundingBox) { return []; }\n    transformAxes(axisBoundingBoxes) {\n        axisBoundingBoxes.forEach((box, index) => this.axes[index].boundingBox = box);\n    }\n    setAxis(feature, axisBoundingBox, origin, end, nTicks = undefined) {\n        const axis = new _axes__WEBPACK_IMPORTED_MODULE_6__.Axis(this.features.get(feature), axisBoundingBox, origin, end, feature, this.initScale, nTicks);\n        axis.updateStyle(this.axisStyle);\n        return axis;\n    }\n    setAxesTitleWidth() { }\n    relocateAxes() {\n        const freeSpace = this.computeBounds();\n        const axisBoundingBoxes = this.buildAxisBoundingBoxes(freeSpace);\n        this.transformAxes(axisBoundingBoxes);\n    }\n    updateSelection(axesSelections) {\n        if (!this.is_in_multiplot)\n            this.selectedIndices = (0,_functions__WEBPACK_IMPORTED_MODULE_1__.intersectArrays)(axesSelections);\n    }\n    updateSize() { this.size = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.width, this.height); }\n    resetAxes() { this.axes.forEach(axis => axis.reset()); }\n    updateDimensions() {\n        this.updateSize();\n        this.computeOffset();\n        this.relocateAxes();\n        this.setAxesTitleWidth();\n    }\n    resetScales() {\n        this.updateDimensions();\n        this.axes.forEach(axis => axis.resetScale());\n    }\n    resetView() {\n        this.resetScales();\n        this.draw();\n    }\n    changeLocationInCanvas(origin, width, height) {\n        this.origin = origin;\n        this.width = width;\n        this.height = height;\n    }\n    boundingBoxResize(origin, width, height) {\n        this.changeLocationInCanvas(origin, width, height);\n        this.resizeUpdate();\n    }\n    resize() {\n        this.updateDimensions();\n        this.axes.forEach(axis => axis.updateTicks());\n    }\n    resizeUpdate() {\n        this.resize();\n        this.draw();\n    }\n    initSelectors() {\n        var _a, _b, _c;\n        this.hoveredIndices = [];\n        this.clickedIndices = [];\n        this.selectedIndices = [];\n        (_a = this.fixedObjects) === null || _a === void 0 ? void 0 : _a.resetShapeStates();\n        (_b = this.absoluteObjects) === null || _b === void 0 ? void 0 : _b.resetShapeStates();\n        (_c = this.relativeObjects) === null || _c === void 0 ? void 0 : _c.resetShapeStates();\n    }\n    resetSelectors() {\n        this.selectionBox = new _shapes__WEBPACK_IMPORTED_MODULE_5__.SelectionBox();\n        this.initSelectors();\n    }\n    reset() {\n        this.resetAxes();\n        this.resetSelectors();\n    }\n    resetSelection() {\n        this.resetRubberBands();\n        this.resetSelectors();\n    }\n    resetRubberBands() {\n        this.axes.forEach(axis => axis.rubberBand.reset());\n        this.selectedIndices = [];\n    }\n    updateSelected(axis) {\n        const selection = [];\n        const vector = axis.stringsToValues(this.features.get(axis.name));\n        vector.forEach((value, index) => axis.isInRubberBand(value) ? selection.push(index) : {});\n        return selection;\n    }\n    isRubberBanded() {\n        let isRubberBanded = true;\n        this.axes.forEach(axis => isRubberBanded = isRubberBanded && axis.rubberBand.length != 0);\n        return isRubberBanded;\n    }\n    drawInZone(context) {\n        const previousCanvas = context.getImageData(0, 0, context.canvas.width, context.canvas.height);\n        this.updateVisibleObjects(context);\n        this.updateCuttingZone(context);\n        const cutDraw = context.getImageData(this.origin.x, this.origin.y, this.size.x, this.size.y);\n        context.globalCompositeOperation = \"source-over\";\n        context.putImageData(previousCanvas, 0, 0);\n        context.putImageData(cutDraw, this.origin.x, this.origin.y);\n    }\n    updateVisibleObjects(context) { }\n    updateCuttingZone(context) {\n        context.globalCompositeOperation = \"destination-in\";\n        context.fill(this.cuttingZone.path);\n    }\n    get cuttingZone() {\n        const axesOrigin = this.axes[0].origin.transform(this.canvasMatrix);\n        return new _primitives__WEBPACK_IMPORTED_MODULE_4__.Rect(axesOrigin, this.axesEnd.subtract(axesOrigin));\n    }\n    get axesEnd() { return new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.axes[this.axes.length - 1].end.x, this.axes[this.axes.length - 1].end.y).transform(this.canvasMatrix); }\n    drawFixedObjects(context) { this.fixedObjects.draw(context); }\n    drawZoneRectangle(context) {\n        const zoneRect = new _shapes__WEBPACK_IMPORTED_MODULE_5__.SelectionBox(this.origin, this.size);\n        zoneRect.fillStyle = \"hsl(203, 90%, 88%)\";\n        zoneRect.hoverStyle = zoneRect.clickedStyle = zoneRect.strokeStyle = \"hsl(203, 90%, 73%)\";\n        zoneRect.alpha = 0.3;\n        zoneRect.lineWidth = 1;\n        zoneRect.dashLine = [7, 7];\n        zoneRect.draw(context);\n        return zoneRect;\n    }\n    drawRelativeObjects(context) { this.relativeObjects = new _collections__WEBPACK_IMPORTED_MODULE_7__.GroupCollection([]); }\n    drawAbsoluteObjects(context) { this.absoluteObjects = new _collections__WEBPACK_IMPORTED_MODULE_7__.GroupCollection(); }\n    computeRelativeObjects() { }\n    draw() {\n        this.context.save();\n        this.drawCanvas();\n        this.context.setTransform(this.canvasMatrix);\n        this.updateAxes();\n        this.computeRelativeObjects();\n        this.context.setTransform(this.relativeMatrix);\n        this.drawRelativeObjects(this.context);\n        this.context.resetTransform();\n        this.drawAbsoluteObjects(this.context);\n        this.context.setTransform(this.relativeMatrix);\n        this.drawSelectionBox(this.context);\n        this.drawZoomBox(this.context);\n        this.context.setTransform(this.canvasMatrix);\n        this.drawFixedObjects(this.context);\n        this.drawTooltips();\n        this.context.resetTransform();\n        this.drawBorders();\n        this.context.restore();\n    }\n    switchSelection() { this.isSelecting = !this.isSelecting; this.draw(); }\n    switchMerge() { }\n    switchZoom() { }\n    switchOrientation() { }\n    switchLogScale() {\n        this.axes.forEach(axis => axis.switchLogScale(this.features.get(axis.name)));\n        this.resetScales();\n        this.draw();\n    }\n    togglePoints() { }\n    toggleAxes() {\n        this.axes.forEach(axis => axis.toggleView());\n        this.draw();\n    }\n    htmlToggleAxes() { this.toggleAxes(); }\n    simpleCluster(inputValue) { }\n    resetClusters() { }\n    updateSelectionBox(frameDown, frameMouse) { this.selectionBox.update(frameDown, frameMouse); }\n    get drawingZone() { return [this.origin, this.size]; }\n    drawSelectionBox(context) {\n        if ((this.isSelecting || this.is_drawing_rubber_band) && this.selectionBox.isDefined) {\n            this.selectionBox.updateScale(this.axes[0].transformMatrix.a, this.axes[1].transformMatrix.d);\n            this.selectionBox.buildRectangle(new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.axes[0].minValue, this.axes[1].minValue), new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.axes[0].interval, this.axes[1].interval));\n            if (this.selectionBox.area != 0) {\n                this.selectionBox.buildPath();\n                this.selectionBox.draw(context);\n            }\n            this.relativeObjects.shapes.push(this.selectionBox);\n        }\n    }\n    drawZoomBox(context) {\n        if (this.isZooming && this.zoomBox.isDefined) {\n            this.zoomBox.buildRectangle(new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.axes[0].minValue, this.axes[1].minValue), new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.axes[0].interval, this.axes[1].interval));\n            this.zoomBox.draw(context);\n        }\n    }\n    updateZoomBox(frameDown, frameMouse) { }\n    zoomBoxUpdateAxes(zoomBox) {\n        this.axes[0].minValue = Math.min(zoomBox.minVertex.x, zoomBox.maxVertex.x);\n        this.axes[0].maxValue = Math.max(zoomBox.minVertex.x, zoomBox.maxVertex.x);\n        this.axes[1].minValue = Math.min(zoomBox.minVertex.y, zoomBox.maxVertex.y);\n        this.axes[1].maxValue = Math.max(zoomBox.minVertex.y, zoomBox.maxVertex.y);\n        this.axes.forEach(axis => axis.saveLocation());\n        this.updateAxes();\n    }\n    drawTooltips() {\n        this.relativeObjects.drawTooltips(this.origin, this.size, this.context, this.is_in_multiplot);\n        this.absoluteObjects.drawTooltips(this.origin, this.size, this.context, this.is_in_multiplot);\n    }\n    mouseTranslate(currentMouse, mouseDown) {\n        return currentMouse.subtract(mouseDown);\n    }\n    mouseMove(canvasMouse, frameMouse, absoluteMouse) {\n        this.fixedObjects.mouseMove(this.context, canvasMouse);\n        this.absoluteObjects.mouseMove(this.context, absoluteMouse);\n        this.relativeObjects.mouseMove(this.context, frameMouse);\n    }\n    projectMouse(e) {\n        const mouseCoords = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(e.offsetX, e.offsetY);\n        return [mouseCoords.scale(this.initScale), mouseCoords.transform(this.relativeMatrix.inverse()), mouseCoords];\n    }\n    mouseDown(canvasMouse, frameMouse, absoluteMouse) {\n        var _a, _b;\n        const fixedClickedObject = this.fixedObjects.mouseDown(canvasMouse);\n        const absoluteClickedObject = this.absoluteObjects.mouseDown(absoluteMouse);\n        const relativeClickedObject = this.relativeObjects.mouseDown(frameMouse);\n        const clickedObject = (_b = (_a = fixedClickedObject !== null && fixedClickedObject !== void 0 ? fixedClickedObject : relativeClickedObject) !== null && _a !== void 0 ? _a : absoluteClickedObject) !== null && _b !== void 0 ? _b : null;\n        return [canvasMouse, frameMouse, clickedObject];\n    }\n    mouseUp(ctrlKey) {\n        if (!this.isSelecting && !this.is_drawing_rubber_band && this.translation.normL1 < 10) {\n            this.absoluteObjects.mouseUp(ctrlKey);\n            this.relativeObjects.mouseUp(ctrlKey);\n        }\n        this.fixedObjects.mouseUp(ctrlKey);\n    }\n    mouseMoveDrawer(canvas, e, canvasDown, frameDown, clickedObject) {\n        const [canvasMouse, frameMouse, absoluteMouse] = this.projectMouse(e);\n        this.isHovered = this.isInCanvas(absoluteMouse);\n        this.mouseMove(canvasMouse, frameMouse, absoluteMouse);\n        if (canvasDown) {\n            const translation = this.mouseTranslate(canvasMouse, canvasDown);\n            if (!(clickedObject instanceof _axes__WEBPACK_IMPORTED_MODULE_6__.Axis)) {\n                if ((!clickedObject || translation.normL1 >= 10) && (!this.isSelecting && !this.isZooming))\n                    this.translate(canvas, translation);\n            }\n            if (this.isSelecting) {\n                if (clickedObject instanceof _shapes__WEBPACK_IMPORTED_MODULE_5__.SelectionBox)\n                    this.updateSelectionBox(clickedObject.minVertex, clickedObject.maxVertex);\n                else\n                    this.updateSelectionBox(frameDown, frameMouse);\n            }\n            this.updateZoomBox(frameDown, frameMouse);\n        }\n        if (this.isZooming || this.isSelecting)\n            canvas.style.cursor = 'crosshair';\n        return [canvasMouse, frameMouse, absoluteMouse];\n    }\n    mouseDownDrawer(canvasMouse, frameMouse, absoluteMouse) {\n        const [canvasDown, frameDown, clickedObject] = this.mouseDown(canvasMouse, frameMouse, absoluteMouse);\n        if (!(clickedObject instanceof _axes__WEBPACK_IMPORTED_MODULE_6__.Axis))\n            this.is_drawing_rubber_band = this.isSelecting;\n        return [canvasDown, frameDown, clickedObject];\n    }\n    mouseUpDrawer(ctrlKey) {\n        if (this.isZooming) {\n            if (this.zoomBox.area != 0)\n                this.zoomBoxUpdateAxes(this.zoomBox);\n            this.zoomBox.update(new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(0, 0), new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(0, 0));\n        }\n        this.mouseUp(ctrlKey);\n        this.draw();\n        return this.resetMouseEvents();\n    }\n    mouseWheelDrawer(e) {\n        this.wheelFromEvent(e);\n        this.updateWithScale();\n    }\n    mouseLeaveDrawer(canvas, shiftKey) {\n        const isZooming = this.isZooming; // TODO: get rid of this with a mousehandler refactor\n        this.mouseUpDrawer(true);\n        this.isZooming = isZooming;\n        this.axes.forEach(axis => {\n            axis.saveLocation();\n            axis.isClicked = axis.isHovered = false;\n        });\n        this.translation = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(0, 0);\n        if (!shiftKey)\n            canvas.style.cursor = 'default';\n        return [false, null];\n    }\n    keyDownDrawer(canvas, keyString, ctrlKey, shiftKey, spaceKey) {\n        if (keyString == \"Control\") {\n            ctrlKey = true;\n            if (spaceKey && this.isHovered)\n                this.resetView();\n            if (shiftKey) {\n                canvas.style.cursor = \"default\";\n                this.isSelecting = false;\n            }\n        }\n        if (keyString == \"Shift\") {\n            shiftKey = true;\n            if (!ctrlKey)\n                this.shiftOnAction(canvas);\n            else {\n                canvas.style.cursor = \"default\";\n                this.isSelecting = false;\n            }\n        }\n        if (keyString == \" \") {\n            spaceKey = true;\n            if (ctrlKey && this.isHovered)\n                this.resetView();\n        }\n        return [ctrlKey, shiftKey, spaceKey];\n    }\n    keyUpDrawer(canvas, keyString, ctrlKey, shiftKey, spaceKey) {\n        if (keyString == \"Control\") {\n            ctrlKey = false;\n            if (shiftKey) {\n                this.isSelecting = true;\n                canvas.style.cursor = \"crosshair\";\n            }\n        }\n        if (keyString == \" \")\n            spaceKey = false;\n        if (keyString == \"Shift\") {\n            shiftKey = false;\n            this.shiftOffAction(canvas);\n        }\n        return [ctrlKey, shiftKey, spaceKey];\n    }\n    translate(canvas, translation) {\n        canvas.style.cursor = 'move';\n        this.translation = translation;\n    }\n    activateSelection(emittedRubberBand, index) { this.is_drawing_rubber_band = true; }\n    shiftOnAction(canvas) {\n        this.isSelecting = true;\n        canvas.style.cursor = 'crosshair';\n        this.draw();\n    }\n    shiftOffAction(canvas) {\n        this.isSelecting = false;\n        this.is_drawing_rubber_band = false;\n        canvas.style.cursor = 'default';\n        this.draw();\n    }\n    axisChangeUpdate(e) { }\n    mouseListener() {\n        // TODO: mouseListener generally suffers from a bad initial design that should be totally rethink in a specific refactor development\n        let clickedObject = null;\n        let canvasMouse = null;\n        let canvasDown = null;\n        let frameMouse = null;\n        let frameDown = null;\n        let absoluteMouse = null;\n        const canvas = document.getElementById(this.canvasID);\n        let ctrlKey = false;\n        let shiftKey = false;\n        let spaceKey = false;\n        this.axes.forEach((axis, index) => axis.emitter.on('rubberBandChange', e => this.activateSelection(e, index)));\n        this.axes.forEach(axis => axis.emitter.on('axisStateChange', e => this.axisChangeUpdate(e)));\n        window.addEventListener('keydown', e => {\n            [ctrlKey, shiftKey, spaceKey] = this.keyDownDrawer(canvas, e.key, ctrlKey, shiftKey, spaceKey);\n        });\n        window.addEventListener('keyup', e => {\n            [ctrlKey, shiftKey, spaceKey] = this.keyUpDrawer(canvas, e.key, ctrlKey, shiftKey, spaceKey);\n        });\n        canvas.addEventListener('mousemove', e => {\n            e.preventDefault();\n            [canvasMouse, frameMouse, absoluteMouse] = this.mouseMoveDrawer(canvas, e, canvasDown, frameDown, clickedObject);\n            this.draw();\n            if (!this.isInCanvas(absoluteMouse))\n                canvasDown = null;\n        });\n        canvas.addEventListener('mousedown', () => {\n            [canvasDown, frameDown, clickedObject] = this.mouseDownDrawer(canvasMouse, frameMouse, absoluteMouse);\n            if (ctrlKey && shiftKey)\n                this.reset();\n        });\n        canvas.addEventListener('mouseup', () => {\n            if (canvasDown)\n                [clickedObject, canvasDown] = this.mouseUpDrawer(ctrlKey);\n            if (!shiftKey)\n                canvas.style.cursor = 'default';\n        });\n        canvas.addEventListener('wheel', e => {\n            e.preventDefault();\n            this.mouseWheelDrawer(e);\n            this.draw();\n        });\n        canvas.addEventListener('mouseleave', () => [ctrlKey, canvasDown] = this.mouseLeaveDrawer(canvas, shiftKey));\n    }\n    resetMouseEvents() {\n        this.is_drawing_rubber_band = false;\n        this.isZooming = false;\n        this.axes.forEach(axis => axis.saveLocation());\n        this.translation = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(0, 0);\n        return [null, null];\n    }\n    regulateAxisScale(axis) {\n        if (!axis.isDate) {\n            if (axis.tickPrecision >= this.MAX_PRINTED_NUMBERS) {\n                if (this.scaleX > 1)\n                    this.scaleX = 1;\n                if (this.scaleY > 1)\n                    this.scaleY = 1;\n            }\n            else if (axis.areAllLabelsDisplayed || axis.tickPrecision < 1) {\n                if (this.scaleX < 1)\n                    this.scaleX = 1;\n                if (this.scaleY < 1)\n                    this.scaleY = 1;\n            }\n        }\n    }\n    regulateScale() {\n        this.axes.forEach(axis => this.regulateAxisScale(axis));\n    }\n    updateWithScale() {\n        this.regulateScale();\n        this.updateAxes(); // needs a refactor\n        this.axes.forEach(axis => axis.saveLocation());\n        [this.scaleX, this.scaleY] = [1, 1];\n        this.viewPoint = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(0, 0);\n    }\n    zoomIn() { this.zoom(new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.origin.x + this.size.x / 2, this.origin.y + this.size.y / 2), 342); }\n    zoomOut() { this.zoom(new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(this.origin.x + this.size.x / 2, this.origin.y + this.size.y / 2), -342); }\n    zoom(center, zFactor) {\n        this.mouseWheel(center, zFactor);\n        this.updateWithScale();\n        this.draw();\n    }\n    wheelFromEvent(e) { this.mouseWheel(new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(e.offsetX, e.offsetY), -Math.sign(e.deltaY)); }\n    mouseWheel(mouseCoords, deltaY) {\n        const zoomFactor = deltaY > 0 ? _constants__WEBPACK_IMPORTED_MODULE_0__.ZOOM_FACTOR : 1 / _constants__WEBPACK_IMPORTED_MODULE_0__.ZOOM_FACTOR;\n        this.scaleX *= zoomFactor;\n        this.scaleY *= zoomFactor;\n        this.viewPoint = new _baseShape__WEBPACK_IMPORTED_MODULE_3__.Vertex(mouseCoords.x, mouseCoords.y).scale(this.initScale);\n    }\n}\n\n\n//# sourceURL=webpack://PlotData/./src/remoteFigure.ts?");

/***/ }),

/***/ "./src/shapeFunctions.ts":
/*!*******************************!*\
  !*** ./src/shapeFunctions.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deserialize\": () => (/* binding */ deserialize),\n/* harmony export */   \"drawTooltip\": () => (/* binding */ drawTooltip),\n/* harmony export */   \"initializeTooltip\": () => (/* binding */ initializeTooltip),\n/* harmony export */   \"styleToLegend\": () => (/* binding */ styleToLegend)\n/* harmony export */ });\n/* harmony import */ var _baseShape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./baseShape */ \"./src/baseShape.ts\");\n/* harmony import */ var _primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./primitives */ \"./src/primitives.ts\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shapes */ \"./src/shapes.ts\");\n\n\n\nfunction deserialize(data, scale) {\n    let shape;\n    if (data.type_ == \"circle\")\n        shape = _primitives__WEBPACK_IMPORTED_MODULE_1__.Circle.deserialize(data, scale);\n    else if (data.type_ == \"contour\")\n        shape = _primitives__WEBPACK_IMPORTED_MODULE_1__.Contour.deserialize(data, scale);\n    else if (data.type_ == \"line2d\")\n        shape = _primitives__WEBPACK_IMPORTED_MODULE_1__.Line.deserialize(data, scale);\n    else if (data.type_ == \"linesegment2d\")\n        shape = _primitives__WEBPACK_IMPORTED_MODULE_1__.LineSegment.deserialize(data, scale);\n    else if (data.type_ == \"wire\")\n        shape = _primitives__WEBPACK_IMPORTED_MODULE_1__.LineSequence.deserialize(data, scale);\n    else if (data.type_ == \"point\")\n        shape = _primitives__WEBPACK_IMPORTED_MODULE_1__.Point.deserialize(data, scale);\n    else if (data.type_ == \"arc\")\n        shape = _primitives__WEBPACK_IMPORTED_MODULE_1__.Arc.deserialize(data, scale);\n    else if (data.type_ == \"text\")\n        return _shapes__WEBPACK_IMPORTED_MODULE_2__.Text.deserialize(data, scale); //TODO: remove return\n    else if (data.type_ == \"label\") {\n        const labelShape = data.shape ? deserialize(data.shape, scale) : new _primitives__WEBPACK_IMPORTED_MODULE_1__.Rect();\n        const fakeLegend = _shapes__WEBPACK_IMPORTED_MODULE_2__.Label.deserialize(data, scale);\n        shape = new _shapes__WEBPACK_IMPORTED_MODULE_2__.Label(labelShape, fakeLegend.text); //TODO: method in label\n    }\n    else if (data.type_ == \"rectangle\")\n        shape = _primitives__WEBPACK_IMPORTED_MODULE_1__.Rect.deserialize(data, scale);\n    else if (data.type_ == \"roundrectangle\")\n        shape = _primitives__WEBPACK_IMPORTED_MODULE_1__.RoundRect.deserialize(data, scale);\n    else\n        throw new Error(`${data.type_} deserialization is not implemented.`);\n    shape.deserializeStyle(data);\n    return shape;\n}\nfunction initializeTooltip(shape, plotOrigin, plotSize, context) {\n    const contextMatrix = context.getTransform();\n    const scale = new _baseShape__WEBPACK_IMPORTED_MODULE_0__.Vertex(1 / contextMatrix.a, 1 / contextMatrix.d);\n    shape.initTooltipOrigin();\n    const tooltip = new _shapes__WEBPACK_IMPORTED_MODULE_2__.Tooltip(shape.tooltipOrigin, shape.tooltipMap, context);\n    tooltip.setFlip(shape);\n    tooltip.insideCanvas(plotOrigin, plotSize, scale);\n    return tooltip;\n}\nfunction drawTooltip(shape, plotOrigin, plotSize, context) {\n    if (shape.isClicked && shape.tooltipMap.size != 0) {\n        const tooltip = initializeTooltip(shape, plotOrigin, plotSize, context);\n        tooltip.draw(context);\n    }\n}\nfunction styleToLegend(shape, legendOrigin, legendSize) {\n    if (!shape)\n        return new _primitives__WEBPACK_IMPORTED_MODULE_1__.Rect();\n    if (shape instanceof _primitives__WEBPACK_IMPORTED_MODULE_1__.Point) {\n        const legend = new _primitives__WEBPACK_IMPORTED_MODULE_1__.Point(legendOrigin.x, legendOrigin.y);\n        legend.size = legendSize.y * 0.9;\n        legend.marker = shape.marker;\n        legend.markerOrientation = shape.markerOrientation;\n        return legend;\n    }\n    if (!shape.isFilled)\n        return new _primitives__WEBPACK_IMPORTED_MODULE_1__.LineSegment(legendOrigin.copy(), legendOrigin.add(legendSize));\n    return new _primitives__WEBPACK_IMPORTED_MODULE_1__.Rect(legendOrigin.copy(), legendSize);\n}\n\n\n//# sourceURL=webpack://PlotData/./src/shapeFunctions.ts?");

/***/ }),

/***/ "./src/shapes.ts":
/*!***********************!*\
  !*** ./src/shapes.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bar\": () => (/* binding */ Bar),\n/* harmony export */   \"Label\": () => (/* binding */ Label),\n/* harmony export */   \"RubberBand\": () => (/* binding */ RubberBand),\n/* harmony export */   \"ScatterPoint\": () => (/* binding */ ScatterPoint),\n/* harmony export */   \"SelectionBox\": () => (/* binding */ SelectionBox),\n/* harmony export */   \"Text\": () => (/* binding */ Text),\n/* harmony export */   \"Tooltip\": () => (/* binding */ Tooltip)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _baseShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./baseShape */ \"./src/baseShape.ts\");\n/* harmony import */ var _shapeFunctions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shapeFunctions */ \"./src/shapeFunctions.ts\");\n/* harmony import */ var _primitives__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./primitives */ \"./src/primitives.ts\");\n\n\n\n\nclass Text extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(text, origin, { width = null, height = null, fontsize = null, multiLine = false, font = 'sans-serif', align = 'left', baseline = 'top', style = '', orientation = 0, color = \"hsl(0, 0%, 0%)\", backgroundColor = \"hsla(0, 0%, 100%, 0)\", isScaled = false, scale = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(1, 1) } = {}) {\n        super();\n        this.text = text;\n        this.origin = origin;\n        this.scale = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(1, 1);\n        this.rowIndices = [];\n        this.offset = 0;\n        this.initializeBoundingBox(origin, width, height, backgroundColor);\n        this.initializeTextStyle(fontsize, multiLine, font, style, orientation, color, align, baseline, isScaled, scale);\n        this.words = this.getWords();\n    }\n    static buildFont(style, fontsize, font) { return `${style} ${fontsize}px ${font}`; }\n    static deserializeTextParams(data) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        const style = `${((_a = data.text_style) === null || _a === void 0 ? void 0 : _a.bold) ? \"bold\" : \"\"}${((_b = data.text_style) === null || _b === void 0 ? void 0 : _b.bold) || ((_c = data.text_style) === null || _c === void 0 ? void 0 : _c.italic) ? \" \" : \"\"}${((_d = data.text_style) === null || _d === void 0 ? void 0 : _d.italic) ? \"italic\" : \"\"}`;\n        return {\n            width: data.max_width,\n            height: data.height,\n            fontsize: (_e = data.text_style) === null || _e === void 0 ? void 0 : _e.font_size,\n            multiLine: data.multi_lines,\n            font: (_f = data.text_style) === null || _f === void 0 ? void 0 : _f.font,\n            align: (_g = data.text_style) === null || _g === void 0 ? void 0 : _g.text_align_x,\n            baseline: (_h = data.text_style) === null || _h === void 0 ? void 0 : _h.text_align_y,\n            style: style,\n            orientation: (_j = data.text_style) === null || _j === void 0 ? void 0 : _j.angle,\n            color: (_k = data.text_style) === null || _k === void 0 ? void 0 : _k.text_color,\n            isScaled: data.text_scaling\n        };\n    }\n    static deserialize(data, scale) {\n        const textParams = Text.deserializeTextParams(data);\n        const text = new Text(data.comment, new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(data.position_x, data.position_y), textParams);\n        text.scale = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(scale.x, scale.y);\n        return text;\n    }\n    get fullFont() { return Text.buildFont(this.style, this.fontsize, this.font); }\n    initializeBoundingBox(origin, width, height, backgroundColor) {\n        this.boundingBox = new _primitives__WEBPACK_IMPORTED_MODULE_3__.Rect(origin, new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(width, height));\n        this.boundingBox.fillStyle = backgroundColor;\n        this.boundingBox.strokeStyle = backgroundColor;\n        this.boundingBox.lineWidth = 1e-6;\n    }\n    initializeTextStyle(fontsize, multiLine, font, style, orientation, color, align, baseline, isScaled, scale) {\n        this.fontsize = fontsize;\n        this.multiLine = multiLine;\n        this.font = font;\n        this.style = style;\n        this.orientation = orientation;\n        this.fillStyle = color;\n        this.align = align;\n        this.baseline = baseline;\n        this.isScaled = isScaled;\n        this.scale = scale;\n    }\n    getXCornersUnscaled(xFirstCorner, xSecondCorner, xMinMaxFactor) {\n        if (this.align == \"center\")\n            return [xFirstCorner * 0.99, xSecondCorner * 1.01];\n        if ([\"right\", \"end\"].includes(this.align))\n            return [xFirstCorner, xSecondCorner != 0 ? xSecondCorner * (1 - xMinMaxFactor) : -Math.sign(this.scale.x)];\n        if ([\"left\", \"start\"].includes(this.align))\n            return [xFirstCorner, xSecondCorner != 0 ? xSecondCorner * (1 + xMinMaxFactor) : Math.sign(this.scale.x)];\n    }\n    getYCornersUnscaled(yFirstCorner, ySecondCorner, yMinMaxFactor) {\n        if (this.baseline == \"middle\")\n            return [yFirstCorner * 0.99, ySecondCorner * 1.01];\n        if ([\"bottom\", \"alphabetic\"].includes(this.baseline))\n            return [yFirstCorner, ySecondCorner != 0 ? ySecondCorner * (1 - yMinMaxFactor) : -Math.sign(this.scale.y)];\n        if ([\"top\", \"hanging\"].includes(this.baseline))\n            return [yFirstCorner, ySecondCorner != 0 ? ySecondCorner * (1 + yMinMaxFactor) : Math.sign(this.scale.y)];\n    }\n    getCornersUnscaled() {\n        const firstCorner = this.origin.copy();\n        const secondCorner = firstCorner.copy();\n        const xMinMaxFactor = Math.sign(secondCorner.x) * 0.01 * Math.sign(this.scale.x);\n        const yMinMaxFactor = Math.sign(secondCorner.y) * 0.01 * Math.sign(this.scale.y);\n        [firstCorner.x, secondCorner.x] = this.getXCornersUnscaled(firstCorner.x, secondCorner.x, xMinMaxFactor);\n        [firstCorner.y, secondCorner.y] = this.getYCornersUnscaled(firstCorner.y, secondCorner.y, yMinMaxFactor);\n        return [firstCorner, secondCorner];\n    }\n    getCornersScaled() {\n        const firstCorner = this.boundingBox.origin.copy();\n        const diagonalVector = this.boundingBox.size.copy();\n        const secondCorner = firstCorner.add(diagonalVector);\n        return [firstCorner, secondCorner];\n    }\n    getBounds() {\n        const [firstCorner, secondCorner] = this.isScaled ? this.getCornersScaled() : this.getCornersUnscaled();\n        return [\n            new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(Math.min(firstCorner.x, secondCorner.x), Math.min(firstCorner.y, secondCorner.y)),\n            new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(Math.max(firstCorner.x, secondCorner.x), Math.max(firstCorner.y, secondCorner.y))\n        ];\n    }\n    automaticFontSize(context) {\n        var _a, _b;\n        let fontsize = Math.min((_a = this.boundingBox.size.y) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY, (_b = this.fontsize) !== null && _b !== void 0 ? _b : Number.POSITIVE_INFINITY);\n        if (fontsize == Number.POSITIVE_INFINITY)\n            fontsize = _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE;\n        context.font = Text.buildFont(this.style, fontsize, this.font);\n        if (context.measureText(this.text).width >= this.boundingBox.size.x)\n            fontsize = fontsize * this.boundingBox.size.x / context.measureText(this.text).width;\n        return fontsize;\n    }\n    setRectOffsetX() {\n        if (this.align == \"center\")\n            return -Math.sign(this.scale.x) * this.width / 2;\n        if ([\"left\", \"start\"].includes(this.align) && this.scale.x < 0)\n            return this.width;\n        if (([\"right\", \"end\"].includes(this.align) && this.scale.x > 0) || ([\"left\", \"start\"].includes(this.align) && this.scale.x < 0))\n            return -this.width;\n        return 0;\n    }\n    setRectOffsetY() {\n        if (this.baseline == \"middle\")\n            return -Math.sign(this.scale.y) * this.height / 2;\n        if ([\"top\", \"hanging\"].includes(this.baseline) && this.scale.y < 0)\n            return this.height;\n        if ([\"bottom\", \"alphabetic\"].includes(this.baseline) && this.scale.y > 0)\n            return -this.fontsize * (this.rowIndices.length - 1);\n        return 0;\n    }\n    setBoundingBoxGeometry(contextMatrix) {\n        this.boundingBox.origin = this.origin.copy();\n        this.boundingBox.origin.x += this.setRectOffsetX() / (this.isScaled ? Math.sign(this.scale.x) : contextMatrix.a);\n        this.boundingBox.origin.y += this.setRectOffsetY() / (this.isScaled ? Math.sign(this.scale.y) : contextMatrix.d);\n        this.boundingBox.size.x = this.width;\n        this.boundingBox.size.y = this.height;\n    }\n    descaleBoundingBox(contextMatrix) {\n        const boundingBox = new _primitives__WEBPACK_IMPORTED_MODULE_3__.Rect(this.boundingBox.origin.copy(), this.boundingBox.size.scale(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(Math.abs(1 / contextMatrix.a), Math.abs(1 / contextMatrix.d))));\n        boundingBox.buildPath();\n        this.boundingBox.path = boundingBox.path;\n    }\n    updateBoundingBox(context) {\n        const contextMatrix = context.getTransform();\n        this.setBoundingBoxGeometry(contextMatrix);\n        this.isScaled ? this.boundingBox.buildPath() : this.descaleBoundingBox(contextMatrix);\n    }\n    buildPath() { this.path = this.boundingBox.path; }\n    static capitalize(value) { return value.charAt(0).toUpperCase() + value.slice(1); }\n    capitalizeSelf() { this.text = Text.capitalize(this.text); }\n    setDrawingProperties(context) {\n        context.font = this.fullFont;\n        context.textAlign = this.align;\n        context.textBaseline = this.baseline;\n        context.fillStyle = this.fillStyle;\n        context.globalAlpha = this.alpha;\n    }\n    buildDrawPath(context) {\n        this.setBoundingBoxState();\n        this.updateBoundingBox(context);\n        this.buildPath();\n        this.boundingBox.draw(context);\n    }\n    drawPath(context) {\n        const contextMatrix = context.getTransform();\n        const origin = this.origin.transform(contextMatrix);\n        context.resetTransform();\n        context.translate(origin.x, origin.y);\n        context.rotate(Math.PI / 180 * this.orientation);\n        if (this.isScaled)\n            context.scale(Math.abs(contextMatrix.a), Math.abs(contextMatrix.d));\n        this.write(this.writtenText, context);\n    }\n    computeContextualAttributes(context) {\n        this.writtenText = this.cleanStartAllRows(this.rowIndices.length == 0 ? this.format(context) : this.formatTextRows());\n    }\n    setBoundingBoxState() {\n        this.boundingBox.isHovered = this.isHovered;\n        this.boundingBox.isClicked = this.isClicked;\n        this.boundingBox.isSelected = this.isSelected;\n    }\n    updateParameters(textParams) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        this.boundingBox.size.x = (_a = textParams.width) !== null && _a !== void 0 ? _a : null;\n        this.boundingBox.size.y = (_b = textParams.height) !== null && _b !== void 0 ? _b : null;\n        this.fontsize = (_c = textParams.fontsize) !== null && _c !== void 0 ? _c : 12;\n        this.multiLine = (_d = textParams.multiLine) !== null && _d !== void 0 ? _d : false;\n        this.font = (_e = textParams.font) !== null && _e !== void 0 ? _e : \"sans-serif\";\n        this.align = (_f = textParams.align) !== null && _f !== void 0 ? _f : null;\n        this.baseline = (_g = textParams.baseline) !== null && _g !== void 0 ? _g : null;\n        this.style = (_h = textParams.style) !== null && _h !== void 0 ? _h : \"\";\n        this.orientation = (_j = textParams.orientation) !== null && _j !== void 0 ? _j : 0;\n        this.boundingBox.fillStyle = (_k = textParams.backgroundColor) !== null && _k !== void 0 ? _k : \"hsla(0, 0%, 100%, 0)\";\n        this.fillStyle = (_l = textParams.color) !== null && _l !== void 0 ? _l : \"hsl(0, 0%, 0%)\";\n        this.scale = textParams.scale;\n    }\n    write(writtenText, context) {\n        context.fillStyle = this.fillStyle;\n        const middleFactor = this.baseline == \"middle\" ? 2 : 1;\n        if (writtenText.length > 1)\n            this.multiLineWrite(writtenText, middleFactor, context);\n        else\n            context.fillText(Text.capitalize(writtenText[0]), 0, this.offset / middleFactor);\n    }\n    multiLineWrite(writtenText, middleFactor, context) {\n        const nRows = writtenText.length - 1;\n        writtenText.forEach((row, index) => {\n            [\"top\", \"hanging\"].includes(this.baseline)\n                ? context.fillText(index == 0 ? Text.capitalize(row) : row, 0, index * this.fontsize + this.offset)\n                : context.fillText(index == 0 ? Text.capitalize(row) : row, 0, (index - nRows / middleFactor) * this.fontsize + this.offset);\n        });\n    }\n    removeEndZeros() {\n        let splitText = this.text.split(\".\");\n        if (splitText.length > 1) {\n            let splitDecimal = splitText[1].split(\"e\");\n            let decimal = splitDecimal[0];\n            if (decimal) {\n                while (decimal[decimal.length - 1] == \"0\")\n                    decimal = decimal.slice(0, -1);\n                if (decimal.length != 0)\n                    this.text = `${splitText[0]}.${decimal}`;\n                else\n                    this.text = splitText[0];\n                if (splitDecimal.length > 1)\n                    this.text = `${this.text}e${splitDecimal[1]}`;\n            }\n        }\n    }\n    getLongestRow(context, writtenText) {\n        context.font = Text.buildFont(this.style, this.fontsize, this.font);\n        return Math.max(...writtenText.map(row => context.measureText(row).width));\n    }\n    formatTextRows() {\n        const writtenText = [];\n        this.rowIndices.slice(0, this.rowIndices.length - 1).forEach((_, rowIndex) => {\n            writtenText.push(this.text.slice(this.rowIndices[rowIndex], this.rowIndices[rowIndex + 1]));\n        });\n        return writtenText;\n    }\n    computeRowIndices(writtenText) {\n        const rowIndices = [0];\n        writtenText.forEach((row, index) => rowIndices.push(rowIndices[index] + row.length));\n        return rowIndices;\n    }\n    formatWithLength(writtenText, fontsize, context) {\n        if (this.multiLine)\n            return this.multiLineSplit(fontsize, context);\n        return [writtenText, this.automaticFontSize(context)];\n    }\n    formatInBoundingBox(context) {\n        var _a, _b;\n        const fontsize = (_a = this.fontsize) !== null && _a !== void 0 ? _a : _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FONTSIZE;\n        if (this.boundingBox.size.x)\n            return this.formatWithLength([this.text], fontsize, context);\n        if (this.boundingBox.size.y)\n            return [[this.text], (_b = this.fontsize) !== null && _b !== void 0 ? _b : this.boundingBox.size.y];\n        return [[this.text], fontsize];\n    }\n    format(context) {\n        const [writtenText, fontsize] = this.formatInBoundingBox(context);\n        this.fontsize = Math.abs(fontsize);\n        this.height = writtenText.length * this.fontsize;\n        this.width = this.getLongestRow(context, writtenText);\n        this.rowIndices = this.computeRowIndices(writtenText);\n        return writtenText;\n    }\n    multiLineSplit(fontsize, context) {\n        var _a;\n        context.font = Text.buildFont(this.style, fontsize, this.font);\n        const oneRowLength = context.measureText(this.text).width;\n        if (oneRowLength < this.boundingBox.size.x) {\n            return [[this.text.trimStart()], fontsize > this.boundingBox.size.y ? (_a = this.boundingBox.size.y) !== null && _a !== void 0 ? _a : fontsize : fontsize];\n        }\n        if (!this.boundingBox.size.y)\n            return [this.fixedFontSplit(context), fontsize];\n        return this.autoFontSplit(fontsize, context);\n    }\n    getWords() {\n        if (this.words)\n            return this.words;\n        return this.splitInWords();\n    }\n    pushSeparatorInWords(pickedChars) {\n        return [this.text[pickedChars], pickedChars + 1];\n    }\n    buildWord(pickedChars, word) {\n        while (!_constants__WEBPACK_IMPORTED_MODULE_0__.TEXT_SEPARATORS.includes(this.text[pickedChars]) && pickedChars < this.text.length) {\n            word += this.text[pickedChars];\n            pickedChars++;\n        }\n        return [word, pickedChars];\n    }\n    buildWords() {\n        const words = [];\n        let pickedChars = 0;\n        while (pickedChars < this.text.length) {\n            let word = \"\";\n            if (_constants__WEBPACK_IMPORTED_MODULE_0__.TEXT_SEPARATORS.includes(this.text[pickedChars]))\n                [word, pickedChars] = this.pushSeparatorInWords(pickedChars);\n            else\n                [word, pickedChars] = this.buildWord(pickedChars, word);\n            words.push(word);\n        }\n        return words.length > 1 ? words : this.text.split(\"\");\n    }\n    splitInWords() {\n        if (this.text.length == 0)\n            return [\"\"];\n        return this.buildWords();\n    }\n    isTextTooWide(context, text) {\n        return context.measureText(text).width > this.boundingBox.size.x;\n    }\n    addPickedWordToRow(row, pickedWords) {\n        return [row + this.words[pickedWords], pickedWords + 1];\n    }\n    computeNewRow(context, pickedWords, rows) {\n        let newRow = '';\n        while (context.measureText(newRow).width < this.boundingBox.size.x && pickedWords < this.words.length) {\n            if (this.isTextTooWide(context, newRow + this.words[pickedWords]) && newRow != '')\n                break;\n            else\n                [newRow, pickedWords] = this.addPickedWordToRow(newRow, pickedWords);\n        }\n        if (newRow.length != 0)\n            rows.push(newRow);\n        return [rows, pickedWords];\n    }\n    fixedFontSplit(context) {\n        let rows = [];\n        let pickedWords = 0;\n        while (pickedWords < this.words.length)\n            [rows, pickedWords] = this.computeNewRow(context, pickedWords, rows);\n        return rows;\n    }\n    cleanStartAllRows(rows) { return rows.map(row => row.trimStart()); }\n    checkWordsLength(context) {\n        for (let i = 0; i < this.words.length - 1; i++) {\n            if (context.measureText(this.words[i]).width > this.boundingBox.size.x)\n                return false;\n        }\n        return true;\n    }\n    computeTextHeight(fontsize, textHeight, rows, context) {\n        if (this.checkWordsLength(context)) {\n            rows = this.fixedFontSplit(context);\n            textHeight = fontsize * rows.length;\n        }\n        return [rows, textHeight];\n    }\n    autoFontSplit(fontsize, context) {\n        let rows = [];\n        let textHeight = Number.POSITIVE_INFINITY;\n        while (textHeight > this.boundingBox.size.y && fontsize > 1) {\n            context.font = Text.buildFont(this.style, fontsize, this.font);\n            [rows, textHeight] = this.computeTextHeight(fontsize, textHeight, rows, context);\n            fontsize--; // TODO: this is weird but it is working. Should be investigated in further devs.\n        }\n        return [rows, fontsize + 1];\n    }\n}\nclass Label extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(shape, text, origin = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0)) {\n        super();\n        this.text = text;\n        this.origin = origin;\n        this.shapeSize = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(30, _constants__WEBPACK_IMPORTED_MODULE_0__.MAX_LABEL_HEIGHT);\n        this.maxWidth = 150;\n        this.isScaled = false;\n        this.text.width = this.maxWidth - this.shapeSize.x;\n        this.getShapeStyle(shape, this.origin);\n        this.buildPath();\n    }\n    buildPath() {\n        this.legend.buildPath();\n        this.path = this.legend.path;\n    }\n    buildUnscaledPath(context) {\n        const matrix = context.getTransform();\n        context.resetTransform();\n        this.buildPath();\n        const path = new Path2D();\n        path.addPath(this.path);\n        this.path = new Path2D();\n        this.path.addPath(path, matrix.inverse());\n        this.path.addPath(this.text.path, matrix.inverse());\n        return path;\n    }\n    setLineSegmentLegendGeometry(legend) {\n        legend.origin.x = this.origin.x;\n        legend.origin.y = this.origin.y + _constants__WEBPACK_IMPORTED_MODULE_0__.LEGEND_MARGIN;\n        legend.end.x = this.origin.x + this.shapeSize.x;\n        legend.end.y = this.origin.y + this.shapeSize.y - _constants__WEBPACK_IMPORTED_MODULE_0__.LEGEND_MARGIN;\n        return legend;\n    }\n    setPointLegendGeometry(legend) {\n        legend.center = this.origin.add(this.shapeSize.divide(2));\n        return legend;\n    }\n    updateLegendGeometry() {\n        if (this.legend instanceof _primitives__WEBPACK_IMPORTED_MODULE_3__.LineSegment)\n            return this.setLineSegmentLegendGeometry(this.legend);\n        if (this.legend instanceof _primitives__WEBPACK_IMPORTED_MODULE_3__.Point)\n            return this.setPointLegendGeometry(this.legend);\n        return new _primitives__WEBPACK_IMPORTED_MODULE_3__.Rect(this.origin, this.shapeSize);\n    }\n    getShapeStyle(shape, origin) {\n        this.legend = (0,_shapeFunctions__WEBPACK_IMPORTED_MODULE_2__.styleToLegend)(shape, origin, this.shapeSize);\n        Object.entries(shape.drawingStyle).map(([key, value]) => this[key] = value);\n    }\n    updateHeight(height) {\n        const heightRatio = height / this.shapeSize.y;\n        this.shapeSize.x *= heightRatio;\n        this.maxWidth *= heightRatio;\n        this.shapeSize.y = height;\n        if (this.legend instanceof _primitives__WEBPACK_IMPORTED_MODULE_3__.Rect)\n            this.legend.size.y = height;\n        else if (this.legend instanceof _primitives__WEBPACK_IMPORTED_MODULE_3__.LineSegment)\n            this.legend.end.y = this.legend.origin.y + height;\n        else if (this.legend instanceof _primitives__WEBPACK_IMPORTED_MODULE_3__.Point)\n            this.legend.size = height;\n        this.text.fontsize = height;\n    }\n    static deserialize(data, scale = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(1, 1)) {\n        const textParams = Text.deserializeTextParams(data);\n        const text = new Text(data.title, new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), textParams);\n        text.isScaled = false;\n        text.baseline = \"middle\";\n        text.align = \"start\";\n        return new Label(new _primitives__WEBPACK_IMPORTED_MODULE_3__.Rect(), text);\n    }\n    deserializeStyle(data) {\n        if (data.rectangle_edge_style) {\n            data.edge_style = data.rectangle_edge_style;\n            this.deserializeEdgeStyle(data);\n        }\n        if (data.rectangle_surface_style) {\n            data.surface_style = data.rectangle_surface_style;\n            this.deserializeSurfaceStyle(data);\n        }\n    }\n    updateOrigin(drawingZone, initScale, nLabels) {\n        this.origin.x = drawingZone.origin.x + drawingZone.size.x - (initScale.x < 0 ? 0 : this.maxWidth);\n        this.origin.y = drawingZone.origin.y + drawingZone.size.y - nLabels * this.shapeSize.y * 1.75 * initScale.y;\n        this.legend = this.updateLegendGeometry();\n        this.text.origin = this.origin.add(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.shapeSize.x + _constants__WEBPACK_IMPORTED_MODULE_0__.LABEL_TEXT_OFFSET, this.shapeSize.y / 2));\n    }\n    drawText(context) {\n        const contextMatrix = context.getTransform();\n        context.resetTransform();\n        this.text.draw(context);\n        context.setTransform(contextMatrix);\n    }\n    drawMembers(context) { this.drawText(context); }\n    isPointInShape(context, point) {\n        return this.legend.isFilled\n            ? context.isPointInPath(this.path, point.x, point.y)\n            : (context.isPointInPath(this.path, point.x, point.y) || context.isPointInStroke(this.path, point.x, point.y));\n    }\n}\nclass Tooltip extends _baseShape__WEBPACK_IMPORTED_MODULE_1__.Shape {\n    constructor(origin, dataToPrint, context) {\n        super();\n        this.origin = origin;\n        this.dataToPrint = dataToPrint;\n        this.textColor = \"hsl(0, 0%, 100%)\";\n        this.fontsize = 10;\n        this.radius = 10;\n        this.isUp = true;\n        this.isFlipper = true;\n        this.setStyle();\n        [this.printedRows, this.size] = this.buildText(context);\n        this.squareOrigin = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.origin.x, this.origin.y);\n    }\n    setStyle() {\n        this.strokeStyle = \"hsl(210, 90%, 20%)\";\n        this.fillStyle = \"hsl(210, 90%, 20%)\";\n        this.alpha = 0.8;\n    }\n    featureValueToTextRow(featureValue, featureKey) {\n        if (featureKey == \"Number\" && featureValue != 1)\n            return `${featureValue} samples`;\n        if (featureKey != \"name\")\n            return featureValue != '' ? `${featureKey}: ${this.formatValue(featureValue)}` : featureKey;\n        return null;\n    }\n    dataToText(context) {\n        const printedRows = [];\n        let textLength = 0;\n        this.dataToPrint.forEach((value, key) => {\n            const text = this.featureValueToTextRow(value, key);\n            const textWidth = context.measureText(text).width;\n            if (textWidth > textLength)\n                textLength = textWidth;\n            if (text)\n                printedRows.push(text);\n        });\n        return [printedRows, textLength];\n    }\n    buildText(context) {\n        context.save();\n        context.font = `${this.fontsize}px sans-serif`;\n        const [printedRows, textLength] = this.dataToText(context);\n        context.restore();\n        return [printedRows, new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(textLength + _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_TEXT_OFFSET * 2, (printedRows.length + 1.5) * this.fontsize)];\n    }\n    formatValue(value) {\n        if (typeof value == \"number\")\n            return Math.round(value * _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_PRECISION) / _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_PRECISION;\n        return value;\n    }\n    ;\n    buildPath() {\n        this.path = new Path2D();\n        const rectOrigin = this.squareOrigin.add(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(-this.size.x / 2, _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_TRIANGLE_SIZE));\n        const triangleCenter = this.origin;\n        triangleCenter.y += _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_TRIANGLE_SIZE / 2 * (this.isUp ? 1 : -1);\n        this.path.addPath(new _primitives__WEBPACK_IMPORTED_MODULE_3__.RoundRect(rectOrigin, this.size, this.radius).path);\n        this.path.addPath(new _primitives__WEBPACK_IMPORTED_MODULE_3__.Triangle(triangleCenter, _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_TRIANGLE_SIZE, this.isUp ? 'down' : 'up').path);\n    }\n    computeTextOrigin(scaling) {\n        let textOrigin = this.squareOrigin;\n        let textOffsetX = -this.size.x / 2 + _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_TEXT_OFFSET;\n        let textOffsetY = (scaling.y < 0 ? -this.size.y - _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_TRIANGLE_SIZE : _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_TRIANGLE_SIZE) + this.fontsize * 1.25;\n        return textOrigin.add(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(textOffsetX, textOffsetY));\n    }\n    writeRow(textOrigin, row, rowIndex, context) {\n        textOrigin.y += rowIndex == 0 ? 0 : this.fontsize;\n        const text = new Text(row, textOrigin, { fontsize: this.fontsize, baseline: \"middle\", style: _constants__WEBPACK_IMPORTED_MODULE_0__.REGEX_SAMPLES.test(row) ? 'bold' : '' });\n        text.fillStyle = this.textColor;\n        text.draw(context);\n    }\n    writeText(textOrigin, context) {\n        this.printedRows.forEach((row, index) => this.writeRow(textOrigin, row, index, context));\n    }\n    updateSquareXOrigin(upRightDiff, downLeftDiff, plotSize) {\n        if (upRightDiff.x < 0)\n            return upRightDiff.x;\n        if (upRightDiff.x > plotSize.x)\n            return upRightDiff.x - plotSize.x;\n        if (downLeftDiff.x < 0)\n            return -downLeftDiff.x;\n        if (downLeftDiff.x > plotSize.x)\n            return plotSize.x - downLeftDiff.x;\n        return 0;\n    }\n    computeYOffset(upRightDiff, downLeftDiff, plotSize) {\n        if (upRightDiff.y < 0) {\n            if (!this.isFlipper)\n                return [upRightDiff.y, upRightDiff.y];\n            this.flip();\n            return [0, -this.size.y - _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_TRIANGLE_SIZE * 2];\n        }\n        if (upRightDiff.y > plotSize.y) {\n            if (!this.isFlipper)\n                return [upRightDiff.y - plotSize.y, upRightDiff.y - plotSize.y];\n            this.flip();\n            return [0, this.size.y + _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_TRIANGLE_SIZE * 2];\n        }\n        if (downLeftDiff.y < 0)\n            return [-downLeftDiff.y, -downLeftDiff.y];\n        if (downLeftDiff.y > plotSize.y)\n            return [downLeftDiff.y - plotSize.y, downLeftDiff.y - plotSize.y];\n        return [0, 0];\n    }\n    insideCanvas(plotOrigin, plotSize, scaling) {\n        const downLeftCorner = this.squareOrigin.add(new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(-this.size.x / 2, _constants__WEBPACK_IMPORTED_MODULE_0__.TOOLTIP_TRIANGLE_SIZE).scale(scaling));\n        const upRightCorner = downLeftCorner.add(this.size.scale(scaling));\n        const upRightDiff = plotOrigin.add(plotSize).subtract(upRightCorner);\n        const downLeftDiff = downLeftCorner.subtract(plotOrigin);\n        const [offsetOrigin, offsetSquareOrigin] = this.computeYOffset(upRightDiff, downLeftDiff, plotSize);\n        this.squareOrigin.x += this.updateSquareXOrigin(upRightDiff, downLeftDiff, plotSize);\n        this.origin.y += offsetOrigin;\n        this.squareOrigin.y += offsetSquareOrigin;\n    }\n    flip() { this.isUp = !this.isUp; }\n    computeContextualAttributes(context) {\n        const contextMatrix = context.getTransform();\n        this.inStrokeScale = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(1 / contextMatrix.a, 1 / contextMatrix.d);\n        this.textOrigin = this.computeTextOrigin(this.inStrokeScale);\n        this.squareOrigin = this.squareOrigin.scale(this.inStrokeScale);\n        this.origin = this.origin.scale(this.inStrokeScale);\n    }\n    setDrawingProperties(context) {\n        context.lineWidth = this.lineWidth;\n        context.strokeStyle = this.strokeStyle;\n        context.fillStyle = this.fillStyle;\n        context.globalAlpha = this.alpha;\n    }\n    buildDrawPath(context) {\n        const contextMatrix = context.getTransform();\n        this.drawnPath = new Path2D();\n        this.buildPath();\n        this.drawnPath.addPath(this.path, new DOMMatrix().scale(contextMatrix.a, contextMatrix.d));\n    }\n    drawPath(context) {\n        context.scale(this.inStrokeScale.x, this.inStrokeScale.y);\n        super.drawPath(context);\n        this.writeText(this.textOrigin, context);\n    }\n    setFlip(shape) { this.isFlipper = shape.tooltipFlip; }\n}\nclass ScatterPoint extends _primitives__WEBPACK_IMPORTED_MODULE_3__.Point {\n    constructor(values, x = 0, y = 0, _size = 12, _marker = 'circle', _markerOrientation = 'up', fillStyle = null, strokeStyle = null) {\n        super(x, y, _size, _marker, _markerOrientation, fillStyle, strokeStyle);\n        this.values = values;\n        this._size = _size;\n        this._marker = _marker;\n        this._markerOrientation = _markerOrientation;\n        this.mean = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex();\n        this.isScaled = false;\n    }\n    static fromPlottedValues(indices, pointsData, pointSize, marker, thresholdDist, tooltipAttributes, features, axes, xName, yName) {\n        const newPoint = new ScatterPoint(indices, 0, 0, pointSize, marker);\n        newPoint.computeValues(pointsData, thresholdDist);\n        newPoint.updateTooltip(tooltipAttributes, features, axes, xName, yName);\n        newPoint.update();\n        return newPoint;\n    }\n    setContextPointInStroke(context) {\n        super.setContextPointInStroke(context);\n        context.lineWidth = 10;\n    }\n    mapClusterColor(index, clusterColors, colors) {\n        const currentColorCounter = clusterColors[index];\n        colors.set(currentColorCounter, colors.get(currentColorCounter) ? colors.get(currentColorCounter) + 1 : 1);\n    }\n    updateMouseState(index, hoveredIndices, clickedIndices, selectedIndices) {\n        if (hoveredIndices.includes(index))\n            this.isHovered = true;\n        if (clickedIndices.includes(index))\n            this.isClicked = true;\n        if (selectedIndices.includes(index))\n            this.isSelected = true;\n    }\n    updateDrawingState(clusterColors, hoveredIndices, clickedIndices, selectedIndices) {\n        const colors = new Map();\n        this.isHovered = this.isClicked = this.isSelected = false;\n        this.values.forEach(index => {\n            if (clusterColors)\n                this.mapClusterColor(index, clusterColors, colors);\n            this.updateMouseState(index, hoveredIndices, clickedIndices, selectedIndices);\n        });\n        return colors;\n    }\n    updateDrawProperties(pointStyles, clusterColors, color, lineWidth, marker) {\n        this.lineWidth = lineWidth;\n        this.setColors(color);\n        if (pointStyles) {\n            const clusterPointStyle = clusterColors ? Object.assign({}, pointStyles[this.values[0]], { strokeStyle: null }) : pointStyles[this.values[0]];\n            this.updateStyle(clusterPointStyle);\n        }\n        else\n            this.marker = marker;\n        this.update();\n    }\n    updateTooltipMap() { this._tooltipMap = new Map([[\"Number\", this.values.length], [\"X mean\", this.mean.x], [\"Y mean\", this.mean.y],]); }\n    ;\n    updateTooltip(tooltipAttributes, features, axes, xName, yName) {\n        this.updateTooltipMap();\n        if (this.values.length == 1) {\n            this.newTooltipMap();\n            tooltipAttributes.forEach(attr => this.tooltipMap.set(attr, features.get(attr)[this.values[0]]));\n            return;\n        }\n        this.tooltipMap.set(`Average ${xName}`, axes[0].isDiscrete ? axes[0].labels[Math.round(this.mean.x)] : this.mean.x);\n        this.tooltipMap.set(`Average ${yName}`, axes[1].isDiscrete ? axes[1].labels[Math.round(this.mean.y)] : this.mean.y);\n        this.tooltipMap.delete('X mean');\n        this.tooltipMap.delete('Y mean');\n    }\n    updateStyle(style) {\n        var _a;\n        super.updateStyle(style);\n        this.marker = this.values.length > 1 ? this.marker : (_a = style.marker) !== null && _a !== void 0 ? _a : this.marker;\n    }\n    sumCoordsAndValues(pointsData) {\n        let centerX = 0;\n        let centerY = 0;\n        let meanX = 0;\n        let meanY = 0;\n        this.values.forEach(index => {\n            centerX += pointsData.xCoords[index];\n            centerY += pointsData.yCoords[index];\n            meanX += pointsData.xValues[index];\n            meanY += pointsData.yValues[index];\n        });\n        return [centerX, centerY, meanX, meanY];\n    }\n    computeValues(pointsData, thresholdDist) {\n        const [centerX, centerY, meanX, meanY] = this.sumCoordsAndValues(pointsData);\n        this.center.x = centerX / this.values.length;\n        this.center.y = centerY / this.values.length;\n        this.size = Math.min(this.size * 1.15 ** (this.values.length - 1), thresholdDist);\n        this.mean.x = meanX / this.values.length;\n        this.mean.y = meanY / this.values.length;\n    }\n}\nclass Bar extends _primitives__WEBPACK_IMPORTED_MODULE_3__.Rect {\n    constructor(values = [], origin = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0)) {\n        super(origin, size);\n        this.values = values;\n        this.origin = origin;\n        this.size = size;\n    }\n    get length() { return this.values.length; }\n    ;\n    get tooltipMap() {\n        return new Map([[\"Number\", this.length], [\"Min\", this.min], [\"Max\", this.max], [\"Mean\", this.mean]]);\n    }\n    computeTooltipOrigin(contextMatrix) {\n        return new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.origin.x + this.size.x / 2, this.origin.y + this.size.y).transform(contextMatrix);\n    }\n    get tooltipFlip() { return false; }\n    setGeometry(origin, size) {\n        this.origin = origin;\n        this.size = size;\n    }\n    computeContextualAttributes(context) {\n        this.tooltipOrigin = this.computeTooltipOrigin(context.getTransform());\n    }\n    draw(context) {\n        if (this.length != 0)\n            super.draw(context);\n    }\n    computeStats(values) {\n        this.min = Math.min(...values);\n        this.max = Math.max(...values);\n        this.mean = values.reduce((a, b) => a + b, 0) / values.length;\n    }\n    updateStyle(origin, size, hoveredIndices, clickedIndices, selectedIndices, fillStyle, strokeStyle, dashLine, lineWidth) {\n        this.setGeometry(origin, size);\n        this.fillStyle = fillStyle;\n        this.strokeStyle = strokeStyle;\n        this.dashLine = dashLine;\n        this.lineWidth = lineWidth;\n        if (this.values.some(valIdx => hoveredIndices.includes(valIdx)))\n            this.isHovered = true;\n        if (this.values.some(valIdx => clickedIndices.includes(valIdx)))\n            this.isClicked = true;\n        if (this.values.some(valIdx => selectedIndices.includes(valIdx)))\n            this.isSelected = true;\n        this.buildPath();\n    }\n}\nclass RubberBand extends _primitives__WEBPACK_IMPORTED_MODULE_3__.Rect {\n    constructor(attributeName, _minValue, _maxValue, isVertical) {\n        super();\n        this.attributeName = attributeName;\n        this._minValue = _minValue;\n        this._maxValue = _maxValue;\n        this.isVertical = isVertical;\n        this.canvasMin = 0;\n        this.canvasMax = 0;\n        this.isInverted = false;\n        this.minUpdate = false;\n        this.maxUpdate = false;\n        this.lastCanvasValues = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(null, null);\n    }\n    get canvasLength() { return Math.abs(this.canvasMax - this.canvasMin); }\n    get length() { return Math.abs(this.maxValue - this.minValue); }\n    set minValue(value) { this._minValue = value; }\n    get minValue() { return this._minValue; }\n    set maxValue(value) { this._maxValue = value; }\n    get maxValue() { return this._maxValue; }\n    get isTranslating() { return !this.minUpdate && !this.maxUpdate && this.isClicked; }\n    selfSend(rubberBands) { rubberBands.set(this.attributeName, new RubberBand(this.attributeName, 0, 0, this.isVertical)); }\n    selfSendRange(rubberBands) {\n        rubberBands.get(this.attributeName).minValue = this.minValue;\n        rubberBands.get(this.attributeName).maxValue = this.maxValue;\n    }\n    updateCoords(canvasCoords, axisOrigin, axisEnd) {\n        const coord = this.isVertical ? \"y\" : \"x\";\n        this.canvasMin = Math.max(canvasCoords.min, axisOrigin[coord]);\n        this.canvasMax = Math.min(canvasCoords.max, axisEnd[coord]);\n        this.canvasMin = Math.min(this.canvasMin, this.canvasMax);\n        this.canvasMax = Math.max(this.canvasMin, this.canvasMax);\n        [this.origin, this.size] = this.computeRectProperties(axisOrigin);\n        this.buildPath();\n    }\n    getVerticalRectProperties(axisOrigin) {\n        return [\n            new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(axisOrigin.x - _constants__WEBPACK_IMPORTED_MODULE_0__.RUBBERBAND_SMALL_SIZE / 2, this.canvasMin),\n            new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(_constants__WEBPACK_IMPORTED_MODULE_0__.RUBBERBAND_SMALL_SIZE, this.canvasLength)\n        ];\n    }\n    getHorizontalRectProperties(axisOrigin) {\n        return [\n            new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.canvasMin, axisOrigin.y - _constants__WEBPACK_IMPORTED_MODULE_0__.RUBBERBAND_SMALL_SIZE / 2),\n            new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.canvasLength, _constants__WEBPACK_IMPORTED_MODULE_0__.RUBBERBAND_SMALL_SIZE)\n        ];\n    }\n    computeRectProperties(axisOrigin) {\n        return this.isVertical ? this.getVerticalRectProperties(axisOrigin) : this.getHorizontalRectProperties(axisOrigin);\n    }\n    reset() {\n        this.minValue = 0;\n        this.maxValue = 0;\n        this.canvasMin = 0;\n        this.canvasMax = 0;\n    }\n    flipMinMax() {\n        if (this.minValue >= this.maxValue) {\n            [this.minValue, this.maxValue] = [this.maxValue, this.minValue];\n            [this.minUpdate, this.maxUpdate] = [this.maxUpdate, this.minUpdate];\n        }\n    }\n    get borderSize() { return Math.min(_constants__WEBPACK_IMPORTED_MODULE_0__.PICKABLE_BORDER_SIZE, this.canvasLength / 3); }\n    translateOnAxis(translation) {\n        this.canvasMin = this.lastCanvasValues.x + translation;\n        this.canvasMax = this.lastCanvasValues.y + translation;\n    }\n    mouseDown(mouseDown) {\n        super.mouseDown(mouseDown);\n        const mouseAxis = this.isVertical ? mouseDown.y : mouseDown.x;\n        this.isClicked = true;\n        if (Math.abs(mouseAxis - this.canvasMin) <= this.borderSize)\n            this.isInverted ? this.maxUpdate = true : this.minUpdate = true;\n        else if (Math.abs(mouseAxis - this.canvasMax) <= this.borderSize)\n            this.isInverted ? this.minUpdate = true : this.maxUpdate = true;\n        else\n            this.lastCanvasValues = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(this.canvasMin, this.canvasMax);\n    }\n    mouseMoveWhileClicked(mouseCoords) {\n        const currentCoord = this.isVertical ? mouseCoords.y : mouseCoords.x;\n        const downCoord = this.isVertical ? this.mouseClick.y : this.mouseClick.x;\n        if (this.minUpdate)\n            this.canvasMin = currentCoord;\n        else if (this.maxUpdate)\n            this.canvasMax = currentCoord;\n        else\n            this.translateOnAxis(currentCoord - downCoord);\n        this.flipMinMax();\n    }\n    mouseMove(context, mouseCoords) {\n        super.mouseMove(context, mouseCoords);\n        if (this.isClicked)\n            this.mouseMoveWhileClicked(mouseCoords);\n    }\n    mouseUp(keepState) {\n        super.mouseUp(false);\n        this.minUpdate = false;\n        this.maxUpdate = false;\n        this.isClicked = false;\n    }\n}\nclass SelectionBox extends _primitives__WEBPACK_IMPORTED_MODULE_3__.Rect {\n    constructor(origin = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0), size = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(0, 0)) {\n        super(origin, size);\n        this.origin = origin;\n        this.size = size;\n        this.minVertex = null;\n        this.maxVertex = null;\n        this._scale = new _baseShape__WEBPACK_IMPORTED_MODULE_1__.Vertex(1, 1);\n        this.leftUpdate = false;\n        this.rightUpdate = false;\n        this.upUpdate = false;\n        this.downUpdate = false;\n        this.mouseClick = this.origin.copy();\n        this.initBoundariesVertex();\n        this.dashLine = _constants__WEBPACK_IMPORTED_MODULE_0__.DASH_SELECTION_WINDOW;\n        this.selectedStyle = this.clickedStyle = this.hoverStyle = this.fillStyle = \"hsla(0, 0%, 100%, 0)\";\n        this.lineWidth = 0.5;\n    }\n    get isDefined() { return (this.minVertex != null && this.maxVertex != null); }\n    setDrawingProperties(context) {\n        super.setDrawingProperties(context);\n        context.lineWidth = (this.isHovered || this.isClicked) ? this.lineWidth * 2 : this.lineWidth;\n    }\n    initBoundariesVertex() {\n        this.minVertex = this.origin.copy();\n        this.maxVertex = this.origin.add(this.size);\n        this.saveMinMaxVertices();\n    }\n    update(minVertex, maxVertex) {\n        this.minVertex = minVertex;\n        this.maxVertex = maxVertex;\n    }\n    updateRectangle(origin, size) {\n        this.origin = origin;\n        this.size = size;\n        this.initBoundariesVertex();\n        this.buildPath();\n    }\n    rubberBandUpdate(rubberBand, coordName) {\n        if (this.isDefined) {\n            if (rubberBand.minValue != rubberBand.maxValue) {\n                this.minVertex[coordName] = rubberBand.minValue;\n                this.maxVertex[coordName] = rubberBand.maxValue;\n            }\n            else\n                this.minVertex = this.maxVertex = null;\n        }\n    }\n    buildRectangle(frameOrigin, frameSize) {\n        this.origin = this.minVertex.copy();\n        this.size = this.maxVertex.subtract(this.origin);\n        this.insideCanvas(frameOrigin, frameSize);\n        this.buildPath();\n    }\n    insideCanvas(drawOrigin, drawSize) {\n        const downLeftCorner = this.origin;\n        const upRightCorner = downLeftCorner.add(this.size);\n        const upRightDiff = drawOrigin.add(drawSize).subtract(upRightCorner);\n        const downLeftDiff = downLeftCorner.subtract(drawOrigin);\n        if (upRightDiff.x < 0)\n            this.size.x += upRightDiff.x;\n        else if (upRightDiff.x > drawSize.x)\n            this.size.x += upRightDiff.x - drawSize.x;\n        if (upRightDiff.y < 0)\n            this.size.y += upRightDiff.y;\n        else if (upRightDiff.y > drawSize.y)\n            this.size.y += upRightDiff.y - drawSize.y;\n        if (downLeftDiff.x < 0) {\n            this.origin.x -= downLeftDiff.x;\n            this.size.x += downLeftDiff.x;\n        }\n        else if (downLeftDiff.x > drawSize.x) {\n            this.origin.x -= downLeftDiff.x - drawSize.x;\n            this.size.x += downLeftDiff.x - drawSize.x;\n        }\n        if (downLeftDiff.y < 0) {\n            this.origin.y -= downLeftDiff.y;\n            this.size.y += downLeftDiff.y;\n        }\n        else if (downLeftDiff.y > drawSize.y) {\n            this.origin.y -= downLeftDiff.y - drawSize.y;\n            this.size.y += downLeftDiff.y - drawSize.y;\n        }\n    }\n    get borderSizeX() { return Math.min(_constants__WEBPACK_IMPORTED_MODULE_0__.PICKABLE_BORDER_SIZE / Math.abs(this._scale.x), Math.abs(this.size.x) / 3); }\n    get borderSizeY() { return Math.min(_constants__WEBPACK_IMPORTED_MODULE_0__.PICKABLE_BORDER_SIZE / Math.abs(this._scale.y), Math.abs(this.size.y) / 3); }\n    saveMinMaxVertices() {\n        this._previousMin = this.minVertex.copy();\n        this._previousMax = this.maxVertex.copy();\n    }\n    updateScale(scaleX, scaleY) {\n        this._scale.x = scaleX;\n        this._scale.y = scaleY;\n    }\n    setUpdateState() {\n        this.isClicked = true;\n        this.leftUpdate = Math.abs(this.mouseClick.x - this.minVertex.x) <= this.borderSizeX;\n        this.rightUpdate = Math.abs(this.mouseClick.x - this.maxVertex.x) <= this.borderSizeX;\n        this.downUpdate = Math.abs(this.mouseClick.y - this.minVertex.y) <= this.borderSizeY;\n        this.upUpdate = Math.abs(this.mouseClick.y - this.maxVertex.y) <= this.borderSizeY;\n    }\n    mouseDown(mouseDown) {\n        super.mouseDown(mouseDown);\n        if (this.isHovered) {\n            this.saveMinMaxVertices();\n            this.setUpdateState();\n        }\n    }\n    mouseMove(context, mouseCoords) {\n        super.mouseMove(context, mouseCoords);\n        if (!(this.leftUpdate || this.rightUpdate || this.downUpdate || this.upUpdate) && this.isClicked) {\n            const translation = mouseCoords.subtract(this.mouseClick);\n            this.minVertex = this._previousMin.add(translation);\n            this.maxVertex = this._previousMax.add(translation);\n        }\n        this.mouseUpdate(mouseCoords);\n    }\n    mouseUpdate(mouseCoords) {\n        if (this.leftUpdate)\n            this.minVertex.x = Math.min(this._previousMax.x, mouseCoords.x);\n        if (this.rightUpdate)\n            this.maxVertex.x = Math.max(this._previousMin.x, mouseCoords.x);\n        if (this.downUpdate)\n            this.minVertex.y = Math.min(this._previousMax.y, mouseCoords.y);\n        if (this.upUpdate)\n            this.maxVertex.y = Math.max(this._previousMin.y, mouseCoords.y);\n        if (this.isClicked)\n            this.mouseFlip(mouseCoords);\n    }\n    mouseFlip(mouseCoords) {\n        if (this.minVertex.x == this._previousMax.x)\n            this.maxVertex.x = mouseCoords.x;\n        if (this.maxVertex.x == this._previousMin.x)\n            this.minVertex.x = mouseCoords.x;\n        if (this.minVertex.y == this._previousMax.y)\n            this.maxVertex.y = mouseCoords.y;\n        if (this.maxVertex.y == this._previousMin.y)\n            this.minVertex.y = mouseCoords.y;\n    }\n    mouseUp(keepState) {\n        super.mouseUp(keepState);\n        this.isClicked = this.leftUpdate = this.rightUpdate = this.upUpdate = this.downUpdate = false;\n    }\n}\n\n\n//# sourceURL=webpack://PlotData/./src/shapes.ts?");

/***/ }),

/***/ "./src/styles.ts":
/*!***********************!*\
  !*** ./src/styles.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Hatching\": () => (/* binding */ Hatching),\n/* harmony export */   \"PointStyle\": () => (/* binding */ PointStyle)\n/* harmony export */ });\nclass PointStyle {\n    constructor({ size = null, color_fill = null, color_stroke = null, stroke_width = null, shape = 'circle', orientation = null, } = {}) {\n        this.size = size;\n        this.fillStyle = color_fill;\n        this.strokeStyle = color_stroke;\n        this.marker = shape;\n        this.lineWidth = stroke_width;\n        this.orientation = orientation;\n    }\n}\nclass Hatching {\n    constructor(name, lineWidth = 0, step = 0) {\n        this.name = name;\n        this.lineWidth = lineWidth;\n        this.step = step;\n    }\n    static deserialize(serialized) {\n        return new Hatching(serialized['name'], serialized['stroke_width'], serialized['hatch_spacing']);\n    }\n    buildTexture(fillStyle) {\n        const nLines = this.lineWidth == 0 ? 0 : 20;\n        const maxSize = nLines * this.step;\n        const hatchCanvas = document.createElement(\"canvas\");\n        hatchCanvas.width = maxSize;\n        hatchCanvas.height = maxSize;\n        const context = this.setContext(hatchCanvas.getContext(\"2d\"), fillStyle);\n        context.beginPath();\n        let xCoord = -((maxSize ** 2 / 2) ** 0.5);\n        let yCoord = (maxSize ** 2 / 2) ** 0.5;\n        for (let i = 0; i <= 2 * nLines; i++) {\n            xCoord += this.step;\n            yCoord -= this.step;\n            context.moveTo(xCoord, yCoord);\n            context.lineTo(xCoord + maxSize, yCoord + maxSize);\n        }\n        context.fillRect(0, 0, maxSize, maxSize);\n        context.stroke();\n        return hatchCanvas;\n    }\n    setContext(context, fillStyle) {\n        context.lineCap = 'square';\n        context.fillStyle = fillStyle;\n        context.strokeStyle = 'black';\n        context.lineWidth = this.lineWidth;\n        return context;\n    }\n}\n\n\n//# sourceURL=webpack://PlotData/./src/styles.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/
/************************************************************************/
/******/
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/core.ts");
/******/
/******/ 	return __webpack_exports__;
/******/ })()
;
});
